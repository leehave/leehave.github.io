{"meta":{"title":"Director","subtitle":"It's going down,I'm yelling timber,You better move,you better dance","description":"Director","author":"Director","url":"https://leehave.github.io"},"pages":[{"title":"tags","date":"2016-07-31T09:38:08.000Z","updated":"2016-07-31T09:38:08.000Z","comments":true,"path":"tags/index.html","permalink":"https://leehave.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"es6中文手册","slug":"es6手册","date":"2016-08-02T09:24:17.000Z","updated":"2016-08-02T09:24:17.000Z","comments":true,"path":"2016/08/02/es6手册/","link":"","permalink":"https://leehave.github.io/2016/08/02/es6手册/","excerpt":"这是一个 ES2015(ES6) 的Cheatsheet，其中包括提示、小技巧、最佳实践和一些代码片段，帮助你完成日复一日的开发工作。 Table of Contents var 与 let / const 声明 代码执行块替换立即执行函数 箭头函数 字符串 解构 模块 参数 类 Symbols Maps WeakMaps Promises Generators Async Await","text":"这是一个 ES2015(ES6) 的Cheatsheet，其中包括提示、小技巧、最佳实践和一些代码片段，帮助你完成日复一日的开发工作。 Table of Contents var 与 let / const 声明 代码执行块替换立即执行函数 箭头函数 字符串 解构 模块 参数 类 Symbols Maps WeakMaps Promises Generators Async Await var versus let / const 除了 var 以外，我们现在多了两个新的标识符来声明变量的存储，它们就是 let 和 const。不同于 var ，let 和 const 语句不会造成声明提升。 一个 var 的例子: 1234567891011var snack = 'Meow Mix';function getFood(food) &#123; if (food) &#123; var snack = 'Friskies'; return snack; &#125; return snack;&#125;getFood(false); // undefined 让我们再观察下面语句中，使用 let 替换了 var 后的表现： 1234567891011let snack = 'Meow Mix';function getFood(food) &#123; if (food) &#123; let snack = 'Friskies'; return snack; &#125; return snack;&#125;getFood(false); // 'Meow Mix' 当我们重构使用 var 的老代码时，一定要注意这种变化。盲目使用 let 替换 var 后可能会导致预期意外的结果。 注意：let 和 const 是块级作用域语句。所以在语句块以外引用这些变量时，会造成引用错误 ReferenceError。 123console.log(x);let x = 'hi'; // ReferenceError: x is not defined 最佳实践: 在重构老代码时，var 声明需要格外的注意。在创建一个新项目时，使用 let 声明一个变量，使用 const 来声明一个不可改变的常量。 (回到目录) Replacing IIFEs with Blocks我们以往创建一个 立即执行函数 时，一般是在函数最外层包裹一层括号。ES6支持块级作用域（更贴近其他语言），我们现在可以通过创建一个代码块（Block）来实现，不必通过创建一个函数来实现， 12345(function () &#123; var food = 'Meow Mix';&#125;());console.log(food); // Reference Error 使用支持块级作用域的ES6的版本： 12345&#123; let food = 'Meow Mix';&#125;console.log(food); // Reference Error (回到目录) Arrow Functions一些时候，我们在函数嵌套中需要访问上下文中的 this。比如下面的例子： 123456789function Person(name) &#123; this.name = name;&#125;Person.prototype.prefixName = function (arr) &#123; return arr.map(function (character) &#123; return this.name + character; // Cannot read property 'name' of undefined &#125;);&#125;; 一种通用的方式是把上下文中的 this 保存在一个变量里： 12345678910function Person(name) &#123; this.name = name;&#125;Person.prototype.prefixName = function (arr) &#123; var that = this; // Store the context of this return arr.map(function (character) &#123; return that.name + character; &#125;);&#125;; 我们也可以把 this 通过属性传进去： 123456789function Person(name) &#123; this.name = name;&#125;Person.prototype.prefixName = function (arr) &#123; return arr.map(function (character) &#123; return this.name + character; &#125;, this);&#125;; 还可以直接使用 bind： 123456789function Person(name) &#123; this.name = name;&#125;Person.prototype.prefixName = function (arr) &#123; return arr.map(function (character) &#123; return this.name + character; &#125;.bind(this));&#125;; 使用 箭头函数，this 的值不用我们再做如上几段代码的特殊处理，直接使用即可。上面的代码可以重写为下面这样： 1234567function Person(name) &#123; this.name = name;&#125;Person.prototype.prefixName = function (arr) &#123; return arr.map(character =&gt; this.name + character);&#125;; 最佳实践：使用箭头函数，再也不用考虑 this 的问题了。 当我们编写只返回一个表达式值的简单函数时，也可以使用箭头函数，如下： 1var squares = arr.map(function (x) &#123; return x * x &#125;); // Function Expression 12const arr = [1, 2, 3, 4, 5];const squares = arr.map(x =&gt; x * x); // Arrow Function for terser implementation 最佳实践：尽可能地多使用 箭头函数。 (回到目录) Strings在ES6中，标准库也被同样增强了，像字符串对象就新增了 .includes() 和 .repeat() 方法。 .includes( )1234var string = 'food';var substring = 'foo';console.log(string.indexOf(substring) &gt; -1); 现在，我们可以使用 .inclues() 方法，替代以往判断内容 &gt; -1 的方式。.includes() 方法会极简地返回一个布尔值结果。 1234const string = 'food';const substring = 'foo';console.log(string.includes(substring)); // true .repeat( )1234567function repeat(string, count) &#123; var strings = []; while(strings.length &lt; count) &#123; strings.push(string); &#125; return strings.join('');&#125; 在ES6中，我们可以使用一个极简的方法来实现重复字符： 12// String.repeat(numberOfRepetitions)'meow'.repeat(3); // 'meowmeowmeow' Template Literals使用 字符串模板字面量，我可以在字符串中直接使用特殊字符，而不用转义。 1var text = \"This string contains \\\"double quotes\\\" which are escaped.\"; 1let text = `This string contains \"double quotes\" which don't need to be escaped anymore.`; 字符串模板字面量 还支持直接插入变量，可以实现字符串与变量的直接连接输出。 1234var name = 'Tiger';var age = 13;console.log('My cat is named ' + name + ' and is ' + age + ' years old.'); 更简单的版本： 1234const name = 'Tiger';const age = 13;console.log(`My cat is named $&#123;name&#125; and is $&#123;age&#125; years old.`); ES5中，我们要这样生成多行文本： 12345var text = ( 'cat\\n' + 'dog\\n' + 'nickelodeon'); 或者： 12345var text = [ 'cat', 'dog', 'nickelodeon'].join('\\n'); 字符串模板字面量 让我们不必特别关注多行字符串中的换行转义符号，直接换行即可： 1234let text = ( `catdognickelodeon`); 字符串模板字面量 内部可以使用表达式，像这样： 12let today = new Date();let text = `The time and date is $&#123;today.toLocaleString()&#125;`; (回到目录) Destructuring解构让我们可以使用非常便捷的语法，直接将数组或者对象中的值直接分别导出到多个变量中， Destructuring Arrays解构数组 12345var arr = [1, 2, 3, 4];var a = arr[0];var b = arr[1];var c = arr[2];var d = arr[3]; 1234let [a, b, c, d] = [1, 2, 3, 4];console.log(a); // 1console.log(b); // 2 Destructuring Objects解构对象 123var luke = &#123; occupation: 'jedi', father: 'anakin' &#125;;var occupation = luke.occupation; // 'jedi'var father = luke.father; // 'anakin' 12345let luke = &#123; occupation: 'jedi', father: 'anakin' &#125;;let &#123;occupation, father&#125; = luke;console.log(occupation); // 'jedi'console.log(father); // 'anakin' (回到目录) ModulesES6之前，浏览器端的模块化代码，我们使用像Browserify这样的库，在 Node.js 中，我们则使用 require。在ES6中，我们现在可以直接使用AMD 和 CommonJS这些模块了。 Exporting in CommonJS1234module.exports = 1;module.exports = &#123; foo: 'bar' &#125;;module.exports = ['foo', 'bar'];module.exports = function bar () &#123;&#125;; Exporting in ES6在ES6中，提供了多种设置模块出口的方式，比如我们要导出一个变量，那么使用 变量名 ： 12export let name = 'David';export let age = 25;​​ 还可以为对象 导出一个列表： 123456789function sumTwo(a, b) &#123; return a + b;&#125;function sumThree(a, b, c) &#123; return a + b + c;&#125;export &#123; sumTwo, sumThree &#125;; 我们也可以使用简单的一个 export 关键字来导出一个结果值： 1234567export function sumTwo(a, b) &#123; return a + b;&#125;export function sumThree(a, b, c) &#123; return a + b + c;&#125; 最后，我们可以 导出一个默认出口： 1234567891011121314function sumTwo(a, b) &#123; return a + b;&#125;function sumThree(a, b, c) &#123; return a + b + c;&#125;let api = &#123; sumTwo, sumThree&#125;;export default api; 最佳实践：总是在模块的 最后 使用 export default 方法。它让模块的出口更清晰明了，节省了阅读整个模块来寻找出口的时间。更多的是，在大量CommonJS模块中，通用的习惯是设置一个出口值或者出口对象。最受这个规则，可以让我们的代码更易读，且更方便的联合使用CommonJS和ES6模块。 Importing in ES6ES6提供了好几种模块的导入方式。我们可以单独引入一个文件： 1import 'underscore'; 这里需要注意的是， 整个文件的引入方式会执行该文件内的最上层代码。 就像Python一样，我们还可以命名引用： 1import &#123; sumTwo, sumThree &#125; from 'math/addition'; 我们甚至可以使用 as 给这些模块重命名： 1234import &#123; sumTwo as addTwoNumbers, sumThree as sumThreeNumbers&#125; from 'math/addition'; 另外，我们能 引入所有的东西（原文：import all the things） （也称为命名空间引入） 1import * as util from 'math/addition'; 最后，我们能可以从一个模块的众多值中引入一个列表： 12import * as additionUtil from 'math/addtion';const &#123; sumTwo, sumThree &#125; = additionUtil; 像这样引用默认对象： 12import api from 'math/addition';// Same as: import &#123; default as api &#125; from 'math/addition'; 我们建议一个模块导出的值应该越简洁越好，不过有时候有必要的话命名引用和默认引用可以混着用。如果一个模块是这样导出的： 12// foos.jsexport &#123; foo as default, foo1, foo2 &#125;; 那我们可以如此导入这个模块的值： 1import foo, &#123; foo1, foo2 &#125; from &apos;foos&apos;; 我们还可以导入commonjs模块，例如React： 12import React from 'react';const &#123; Component, PropTypes &#125; = React; 更简化版本： 1import React, &#123; Component, PropTypes &#125; from 'react'; 注意：被导出的值是被 绑定的（原文：bingdings），而不是引用。所以，改变一个模块中的值的话，会影响其他引用本模块的代码，一定要避免此种改动发生。 (回到目录) Parameters在ES5中，许多种方法来处理函数的 参数默认值（default values），参数数量（indefinite arguments），参数命名（named parameters）。ES6中，我们可以使用非常简洁的语法来处理上面提到的集中情况。 Default Parameters12345function addTwoNumbers(x, y) &#123; x = x || 0; y = y || 0; return x + y;&#125; ES6中，我们可以简单为函数参数启用默认值： 123function addTwoNumbers(x=0, y=0) &#123; return x + y;&#125; 123addTwoNumbers(2, 4); // 6addTwoNumbers(2); // 2addTwoNumbers(); // 0 Rest ParametersES5中，遇到参数数量不确定时，我们只能如此处理： 12345function logArguments() &#123; for (var i=0; i &lt; arguments.length; i++) &#123; console.log(arguments[i]); &#125;&#125; 使用 rest 操作符，我们可以给函数传入一个不确定数量的参数列表： 12345function logArguments(...args) &#123; for (let arg of args) &#123; console.log(arg); &#125;&#125; Named Parameters命名函数ES5中，当我们要处理多个 命名参数 时，通常会传入一个 选项对象 的方式，这种方式被jQuery采用。 12345function initializeCanvas(options) &#123; var height = options.height || 600; var width = options.width || 400; var lineStroke = options.lineStroke || 'black';&#125; 我们可以利用上面提到的新特性 解构 ，来完成与上面同样功能的函数：We can achieve the same functionality using destructuring as a formal parameterto a function: 12345function initializeCanvas( &#123; height=600, width=400, lineStroke='black'&#125;) &#123; // ... &#125; // Use variables height, width, lineStroke here 如果我们需要把这个参数变为可选的，那么只要把该参数解构为一个空对象就好了： 1234function initializeCanvas( &#123; height=600, width=400, lineStroke='black'&#125; = &#123;&#125;) &#123; // ... &#125; Spread Operator我们可以利用展开操作符（Spread Operator）来把一组数组的值，当作参数传入： 1Math.max(...[-1, 100, 9001, -32]); // 9001 (回到目录) Classes在ES6以前，我们实现一个类的功能的话，需要首先创建一个构造函数，然后扩展这个函数的原型方法，就像这样： 123456789function Person(name, age, gender) &#123; this.name = name; this.age = age; this.gender = gender;&#125;Person.prototype.incrementAge = function () &#123; return this.age += 1;&#125;; 继承父类的子类需要这样： 1234567891011function Personal(name, age, gender, occupation, hobby) &#123; Person.call(this, name, age, gender); this.occupation = occupation; this.hobby = hobby;&#125;Personal.prototype = Object.create(Person.prototype);Personal.prototype.constructor = Personal;Personal.prototype.incrementAge = function () &#123; return Person.prototype.incrementAge.call(this) += 20;&#125;; ES6提供了一些语法糖来实现上面的功能，我们可以直接创建一个类： 1234567891011class Person &#123; constructor(name, age, gender) &#123; this.name = name; this.age = age; this.gender = gender; &#125; incrementAge() &#123; this.age += 1; &#125;&#125; 继承父类的子类只要简单的使用 extends 关键字就可以了： 12345678910111213class Personal extends Person &#123; constructor(name, age, gender, occupation, hobby) &#123; super(name, age, gender); this.occupation = occupation; this.hobby = hobby; &#125; incrementAge() &#123; super.incrementAge(); this.age += 20; console.log(this.age); &#125;&#125; 最佳实践：ES6新的类语法把我们从晦涩难懂的实现和原型操作中解救出来，这是个非常适合初学者的功能，而且能让我们写出更干净整洁的代码。 (回到目录) Symbols符号（Symbols）在ES6版本之前就已经存在了，但现在我们拥有一个公共的接口来直接使用它们。Symbols对象是一旦创建就不可以被更改的（immutable）而且能被用做hash数据类型中的键。 Symbol( )调用 Symbol() 或者 Symbol(描述文本) 会创建一个唯一的、在全局中不可以访问的符号对象。一个 Symbol() 的应用场景是：在自己的项目中使用第三方代码库，且你需要给他们的对象或者命名空间打补丁代码，又不想改动或升级第三方原有代码的时候。举个例子，如果你想给 React.Component 这个类添加一个 refreshComponent 方法，但又确定不了这个方法会不会在下个版本中加入，你可以这么做： 12345const refreshComponent = Symbol();React.Component.prototype[refreshComponent] = () =&gt; &#123; // do something&#125; Symbol.for(key)使用 Symbol.for(key) 也是会创建一个不可改变的Symbol对象，但区别于上面的创建方法，这个对象是在全局中可以被访问到的。调用两次 Symbol.for(key) 会返回相同的Symbol实例。 提示：这并不同于 Symbol(description)。 123Symbol('foo') === Symbol('foo') // falseSymbol.for('foo') === Symbol('foo') // falseSymbol.for('foo') === Symbol.for('foo') // true 一个Symbols常用的使用场景，是需要使用特别 Symbol.for(key) 方法来实现代码间的协作。这能让你在你的代码中，查找包含已知的接口的第三方代码中Symbol成员。（译者：这句话好难翻。。。原文：This can beachieved by having your code look for a Symbol member on object arguments from third parties that contain some known interface. ）举个例子： 123456789function reader(obj) &#123; const specialRead = Symbol.for('specialRead'); if (obj[specialRead]) &#123; const reader = obj[specialRead](); // do something with reader &#125; else &#123; throw new TypeError('object cannot be read'); &#125;&#125; 之后在另一个库中： 12345678const specialRead = Symbol.for('specialRead');class SomeReadableType &#123; [specialRead]() &#123; const reader = createSomeReaderFrom(this); return reader; &#125;&#125; 注意：Symbol.iterable 在ES6中像其他可枚举的对象，如数组，字符串，generators一样，当这个方法被调用时会激活一个枚举器并返回一个对象。 (回到目录) MapsMaps 是一个Javascript中很重要（迫切需要）的数据结构。在ES6之前，我们创建一个 hash 通常是使用一个对象： 123var map = new Object();map[key1] = 'value1';map[key2] = 'value2'; 但是，这样的代码无法避免函数被特别的属性名覆盖的意外情况： 12&gt; getOwnProperty(&#123; hasOwnProperty: 'Hah, overwritten'&#125;, 'Pwned');&gt; TypeError: Property 'hasOwnProperty' is not a function Maps 让我们使用 set，get 和 search 操作数据。 1234let map = new Map();&gt; map.set('name', 'david');&gt; map.get('name'); // david&gt; map.has('name'); // true Maps最强大的地方在于我们不必只能使用字符串来做key了，现在可以使用任何类型来当作key，而且key不会被强制类型转换为字符串。 123456789101112let map = new Map([ ['name', 'david'], [true, 'false'], [1, 'one'], [&#123;&#125;, 'object'], [function () &#123;&#125;, 'function']]);for (let key of map.keys()) &#123; console.log(typeof key); // &gt; string, boolean, number, object, function&#125; 提示：当使用 map.get() 判断值是否相等时，非基础类型比如一个函数或者对象，将不会正常工作。有鉴于此，还是建议使用字符串，布尔和数字类型的数据类型。 我们还可以使用 .entries() 方法来遍历整个map对象： 123for (let [key, value] of map.entries()) &#123; console.log(key, value);&#125; (回到目录) WeakMaps在ES5之前的版本，我们为了存储私有数据，有好几种方法。像使用这种下划线命名约定： 123456789class Person &#123; constructor(age) &#123; this._age = age; &#125; _incrementAge() &#123; this._age += 1; &#125;&#125; 在一个开源项目中，命名规则很难维持得一直很好，这样经常会造成一些困扰。此时，我们可以选择使用WeakMaps来替代Maps来存储我们的数据： 1234567891011121314let _age = new WeakMap();class Person &#123; constructor(age) &#123; _age.set(this, age); &#125; incrementAge() &#123; let age = _age.get(this) + 1; _age.set(this, age); if (age &gt; 50) &#123; console.log('Midlife crisis'); &#125; &#125;&#125; 使用WeakMaps来保存我们私有数据的理由之一是不会暴露出属性名，就像下面的例子中的 Reflect.ownKeys()： 123&gt; const person = new Person(50);&gt; person.incrementAge(); // 'Midlife crisis'&gt; Reflect.ownKeys(person); // [] 一个使用WeakMaps存储数据更实际的例子，就是有关于一个DOM元素和对该DOM元素（有污染）地操作： 1234567891011121314let map = new WeakMap();let el = document.getElementById('someElement');// Store a weak reference to the element with a keymap.set(el, 'reference');// Access the value of the elementlet value = map.get(el); // 'reference'// Remove the referenceel.parentNode.removeChild(el);el = null;value = map.get(el); // undefined 上面的例子中，一个对象被垃圾回收期给销毁了，WeakMaps会自动的把自己内部所对应的键值对数据同时销毁。 提示：结合这个例子，再考虑下jQuery是如何实现缓存带有引用的DOM元素这个功能的，使用了WeakMaps的话，当被缓存的DOM元素被移除的时，jQuery可以自动释放相应元素的内存。通常情况下，在涉及DOM元素存储和缓存的情况下，使用WeakMaps是非常适合的。 (回到目录) PromisesPromises让我们让我们多缩进难看的代码（回调地狱）： 1234567891011func1(function (value1) &#123; func2(value1, function (value2) &#123; func3(value2, function (value3) &#123; func4(value3, function (value4) &#123; func5(value4, function (value5) &#123; // Do something with value 5 &#125;); &#125;); &#125;); &#125;);&#125;); 写成这样： 1234567func1(value1) .then(func2) .then(func3) .then(func4) .then(func5, value5 =&gt; &#123; // Do something with value 5 &#125;); 在ES6之前，我们使用bluebird 或者Q。现在我们有了原生版本的 Promises： 123new Promise((resolve, reject) =&gt; reject(new Error('Failed to fulfill Promise'))) .catch(reason =&gt; console.log(reason)); 这里有两个处理函数，resolve（当Promise执行成功完毕时调用的回调函数） 和 reject （当Promise执行不接受时调用的回调函数） Promises的好处：大量嵌套错误回调函数会使代码变得难以阅读理解。使用了Promises，我们可以让我们代码变得更易读，组织起来更合理。此外，Promise处理后的值，无论是解决还是拒绝的结果值，都是不可改变的。 下面是一些使用Promises的实际例子： 1234567var fetchJSON = function(url) &#123; return new Promise((resolve, reject) =&gt; &#123; $.getJSON(url) .done((json) =&gt; resolve(json)) .fail((xhr, status, err) =&gt; reject(status + err.message)); &#125;);&#125;; 我们还可以使用 Promise.all() 来异步的 并行 处理一个数组的数据。 123456789101112131415var urls = [ 'http://www.api.com/items/1234', 'http://www.api.com/items/4567'];var urlPromises = urls.map(fetchJSON);Promise.all(urlPromises) .then(function (results) &#123; results.forEach(function (data) &#123; &#125;); &#125;) .catch(function (err) &#123; console.log('Failed: ', err); &#125;); (回到目录) Generators就像Promises如何让我们避免回调地狱一样，Generators也可以使我们的代码扁平化，同时给予我们开发者像开发同步代码一样的感觉来写异步代码。Generators本质上是一种支持的函数，随后返回表达式的值。Generators实际上是支持暂停运行，随后根据上一步的返回值再继续运行的一种函数。 下面代码是一个使用generators函数的简单例子： 123456789101112function* sillyGenerator() &#123; yield 1; yield 2; yield 3; yield 4;&#125;var generator = sillyGenerator();&gt; console.log(generator.next()); // &#123; value: 1, done: false &#125;&gt; console.log(generator.next()); // &#123; value: 2, done: false &#125;&gt; console.log(generator.next()); // &#123; value: 3, done: false &#125;&gt; console.log(generator.next()); // &#123; value: 4, done: false &#125; 就像上面的例子，当next运行时，它会把我们的generator向前“推动”，同时执行新的表达式。我们能利用Generators来像书写同步代码一样书写异步代码。 1234567// Hiding asynchronousity with Generatorsfunction request(url) &#123; getJSON(url, function(response) &#123; generator.next(response); &#125;);&#125; 这里我们写个generator函数将要返回我们的数据： 123456function* getData() &#123; var entry1 = yield request('http://some_api/item1'); var data1 = JSON.parse(entry1); var entry2 = yield request('http://some_api/item2'); var data2 = JSON.parse(entry2);&#125; 借助于 yield，我们可以保证 entry1 确实拿到数据并转换后再赋值给 data1。 当我们使用generators来像书写同步代码一样书写我们的异步代码逻辑时，没有一种清晰简单的方式来处理期间可能会产生的错误或者异常。在这种情况下，我们可以在我们的generator中引入Promises来处理，就像下面这样： 12345function request(url) &#123; return new Promise((resolve, reject) =&gt; &#123; getJSON(url, resolve); &#125;);&#125; 我们再写一个函数，其中使用 next 来步进我们的generator的同事，再利用我们上面的 request 方法来产生（yield）一个Promise。 12345678910function iterateGenerator(gen) &#123; var generator = gen(); var ret; (function iterate(val) &#123; ret = generator.next(); if(!ret.done) &#123; ret.value.then(iterate); &#125; &#125;)();&#125; 在Generator中引入了Promises后，我们就可以通过Promise的 .catch 和 reject 来捕捉和处理错误了。使用了我们新版的Generator后，新版的调用就像老版本一样简单可读（译者注：有微调）： 123456iterateGenerator(function* getData() &#123; var entry1 = yield request('http://some_api/item1'); var data1 = JSON.parse(entry1); var entry2 = yield request('http://some_api/item2'); var data2 = JSON.parse(entry2);&#125;); 在使用Generator后，我们可以重用我们的老版本代码实现，以此展示了Generator的力量。当使用Generators和Promises后，我们可以像书写同步代码一样书写异步代码的同时优雅地解决了错误处理问题。此后，我们实际上可以开始利用更简单的一种方式了，它就是async-await。 (回到目录) Async Awaitasync await 随着ES2016版本就要发布了，它给我们提供了一种更轻松的、更简单的可以替代的实现上面 Generators 配合 Promises 组合代码的一种编码方式，让我们来看看例子： 12345678910111213141516var request = require('request');function getJSON(url) &#123; return new Promise(function(resolve, reject) &#123; request(url, function(error, response, body) &#123; resolve(body); &#125;); &#125;);&#125;async function main() &#123; var data = await getJSON(); console.log(data); // NOT undefined!&#125;main(); 它们看上去和Generators很像。我（作者）强烈推荐使用 async await 来替代Generators + Promises的写法。这里是个很好的学习资源，让我们学习和使用这项ES7中的新功能。 (回到目录)","categories":[],"tags":[{"name":"ECMAscript","slug":"ECMAscript","permalink":"https://leehave.github.io/tags/ECMAscript/"}]},{"title":"导演很无语","slug":"something","date":"2016-07-31T16:03:29.000Z","updated":"2016-07-31T16:03:29.000Z","comments":true,"path":"2016/08/01/something/","link":"","permalink":"https://leehave.github.io/2016/08/01/something/","excerpt":"","text":"有点蛋疼的是,换了工作后,博客源文件忘了拷走,现在重新搭建了一遍,好在是用 ‘nodejs’ 强力驱动,hexo的博客驱动还是很给力的,我这种懒人,弄了个WordPress到现在还没设计好怎么搞好,最近发生了好多事,措手不及也是意料之中。————————————————————————分割线 最近在学各种js框架和夯实基础(走的时候茶杯水漏了把犀牛书弄湿了,心塞–),在这分享点资源awesome前端库(https://www.awesomes.cn/) 醉牛前端(http://f2er.club/) talkingcoder(http://www.talkingcoder.com/) React Native 构建 Facebook F8 2016 App / React Native 开发指南http://f8-app.liaohuqiu.net/ React-Native入门指南https://github.com/vczero/react-native-lesson 30天学习React Native教程https://github.com/fangwei716/30-days-of-react-native React-Native视频教程(部分免费)https://egghead.io/technologies/react Angularjs angular2https://angular.cn/ 使用typescript撰写的angularjs风格apphttps://github.com/NoctisHsu/91APP-TypeScript-Angularjs Vuejs 基于vue.js重写Cnodejs.org社区的webapphttps://github.com/shinygang/Vue-cnodejs **基于 Vue.js 的移动端组件库Mint Uihttp://mint-ui.github.io/#!/zh-cn 这个不得不说一个 国产的vuer们称作kpi项目的 阿里巴巴的weexhttp://alibaba.github.io/weex/doc/tutorial.html","categories":[],"tags":[]},{"title":"Webpack 中文指南","slug":"webpack","date":"2016-07-31T15:32:37.000Z","updated":"2016-07-31T15:32:37.000Z","comments":true,"path":"2016/07/31/webpack/","link":"","permalink":"https://leehave.github.io/2016/07/31/webpack/","excerpt":"Webpack 是当下最热门的前端资源模块化管理和打包工具。它可以将许多松散的模块按照依赖和规则打包成符合生产环境部署的前端资源。还可以将按需加载的模块进行代码分隔，等到实际需要的时候再异步加载。通过 loader 的转换，任何形式的资源都可以视作模块，比如 CommonJs 模块、 AMD 模块、 ES6 模块、CSS、图片、 JSON、Coffeescript、 LESS 等。 主站 · 下载电子版 · 国内镜像1（掘金）· 国内镜像2（极客学院）","text":"Webpack 是当下最热门的前端资源模块化管理和打包工具。它可以将许多松散的模块按照依赖和规则打包成符合生产环境部署的前端资源。还可以将按需加载的模块进行代码分隔，等到实际需要的时候再异步加载。通过 loader 的转换，任何形式的资源都可以视作模块，比如 CommonJs 模块、 AMD 模块、 ES6 模块、CSS、图片、 JSON、Coffeescript、 LESS 等。 主站 · 下载电子版 · 国内镜像1（掘金）· 国内镜像2（极客学院） 贡献内容如果你想参与这本书的共同创作，修改或添加内容，可以先 Fork 这本书的仓库，然后将修改的内容提交 Pull requests ；或者创建 Issues。 Fork 后的仓库如何同步本仓库？ 123456789101112// 添加 upstream 源，只需执行一次$ git remote add upstream git@github.com:zhaoda/webpack-handbook.git// 拉取远程代码$ git pull upstream master// 提交修改$ git add .$ git commit// 更新 fork 仓库$ git push origin master 更多参考： Syncing a fork 注意，本书内容在 /content 目录中， gh-pages 分支和 Wiki 版是通过脚本自动生成的。 生成电子书这本书使用 Gitbook 撰写并生成网站，请查看 package.json 中的 scripts 配置和 /scripts 目录中的脚本来了解这本书的构建和发布过程。 123456789101112131415161718192021222324// 初始化 nodejs 依赖$ npm install// 安装 gitbook 插件$ npm install gitbook-cli -g$ gitbook install ./content// 启动 gitbook 服务开始撰写工作$ npm run serve-gitbook// 生成 gitbook$ npm run generate-gitbook// 生成 wiki$ npm run generate-wiki// 发布到 gh-pages 分支$ npm run deploy-gitbook// 发布到 wiki$ npm run deploy-wiki// 生成并发布，是上面4条命令的快捷方式，通常编辑内容后只需要进行这个操作$ npm run generate-and-deploy 更新日志https://github.com/zhaoda/webpack-handbook/commits/master 版权许可 Webpack 中文指南 由 赵达 创作，采用 知识共享 署名-非商业性使用 4.0 国际 许可协议进行许可。","categories":[],"tags":[{"name":"webpack","slug":"webpack","permalink":"https://leehave.github.io/tags/webpack/"},{"name":"前端打包工具","slug":"前端打包工具","permalink":"https://leehave.github.io/tags/前端打包工具/"},{"name":"模块化","slug":"模块化","permalink":"https://leehave.github.io/tags/模块化/"}]},{"title":"Hello World","slug":"hello-world","date":"2016-07-31T15:15:43.000Z","updated":"2016-07-31T15:15:43.000Z","comments":true,"path":"2016/07/31/hello-world/","link":"","permalink":"https://leehave.github.io/2016/07/31/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}