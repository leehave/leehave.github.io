{"meta":{"title":"Director","subtitle":"只为装逼而写,WEB前端笔记集合","description":"Director","author":"Director","url":"https://leehave.github.io"},"pages":[{"title":"tags","date":"2016-07-31T09:38:08.000Z","updated":"2016-07-31T09:38:08.000Z","comments":true,"path":"tags/index.html","permalink":"https://leehave.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"除去复制粘贴,你对JavaScript有多了解,JavaScript入门级笔试题","slug":"JavaScript入门级笔试题","date":"2017-04-01T12:58:37.000Z","updated":"2017-04-01T12:58:37.000Z","comments":true,"path":"2017/04/01/JavaScript入门级笔试题/","link":"","permalink":"https://leehave.github.io/2017/04/01/JavaScript入门级笔试题/","excerpt":"","text":"1.下面表达式的运算结果是什么？1console.log(1 + - + + + - + 1); 2.下面表达式的运算结果是什么？12var a = 10, b = 20, c = (a++,b++,100); console.log(c); 3.实现一个函数，返回输入参数是否为质数123function isZhiShu(m)&#123; /*返回布尔值*/ &#125; 4.将改字符串按照字母出现的次数由大到小重新排列,如果不是字符串类型，不做任何修改，返回FALSE1234567/** * 如果传入的参数是字符串，则将改字符串按照字母出现的次数由大到小重新排列 * exp：‘ddxsss’=&gt;&apos;sssddx&apos; * 如果不是字符串类型，不做任何修改，返回FALSE * @return &#123;Boolean&#125; 是否转换成功 */ function sortStringByCount()&#123;&#125; 5.获取斐波那契数列的第n个值123456/** * 获取斐波那契数列的第n个值 * 如果n不是有效的数字则返回undefined * @return &#123;Number|undefined&#125; */ function getFBN(n)&#123;&#125; 6.计算从10到100中能被3或5整除的数的和1234/** * 计算从10到100中能被3或5整除的数的和 * @return &#123;number&#125; [description] */ function getSum() 7.将传入的字符串翻转输出，如果不是字符串输出undefined123/** * 将传入的字符串翻转输出，如果不是字符串输出undefined * @return &#123;String |undefined&#125; [description] */ 8.实现一个函数，来判断输入字符串是否为“回文”1实现一个函数，来判断输入字符串是否为“回文”（忽略大小写），如：Helleh，王中王 9.去除字符串中重复的字符1去除字符串中重复的字符 10.输出1000内水仙花数123456/** * 输出1000内水仙花数 * 水仙花数是指一个 n 位数 ( n≥3 )，它的每个位上的数字的 n 次幂之和等于它本身。（例如：1^3 + 5^3+ 3^3 = 153） * 三位的水仙花数共有4个：153，370，371，407 * @return &#123;undefined&#125; [description] */ function shuixianhua()&#123;&#125;","categories":[],"tags":[]},{"title":"TCP/IP的一点笔记","slug":"TCP|IP笔记","date":"2017-01-19T02:52:35.000Z","updated":"2017-01-19T02:52:35.000Z","comments":true,"path":"2017/01/19/TCP|IP笔记/","link":"","permalink":"https://leehave.github.io/2017/01/19/TCP|IP笔记/","excerpt":"","text":"建立连接 TCP协议提供可靠的面向连接服务，采用三次握手建立连接。 第一次握手：建立连接时，客户端发送SYN包(syn=j)到服务器，并进入SYN_SEND状态，等待服务器确认； 第二次握手：服务器收到SYN包，向客户端返回ACK（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RCVD状态； 第三次握手：客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。 完成三次握手，客户端与服务器开始传送数据，也就是ESTABLISHED状态。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253什么是SYN包？SYN包是什么意思？TCP连接的第一个包，非常小的一种数据包。SYN攻击包括大量此类的包，由于这些包看上去来自实际不存在的站点，因此无法有效进行处理。当两台计算机在TCP连接上进行会话时，连接一定会首先被初始化。完成这项任务的包叫作SYN。一个SYN包简单的表明另一台计算机已经做好了会话的准备。只有发出服务请求的计算机才发送SYN包。所以如果你仅拒绝进来的SYN包，它将终止其它计算机打开你计算机上的服务，但是不会终止你使用其它计算机上的服务，如果它没有拒绝你发送的SYN包的话。SYN攻击最近对SYN Flood特别感兴趣，看到一个关于SYN cookie firewall的文章，在google搜了一下，没中文的，翻译他一下 本文介绍了４个概念 一：介绍SYN 二：什么是SYN洪水攻击 三：什么是SYN cookie 四：什么是SYN cookie防火墙 C=client(客户器) S=Server(服务器) FW=Firewall(防火墙) 一：介绍SYN SYN cookie是一个防止SYN洪水攻击技术。他由D. J. Bernstein和Eric Schenk发明。现在SYN COOKIE已经是linux内核的一部分了（我插一句 ，默认的stat是no）,但是在linux系统的执行过程中它只保护linux系统。我们这里只是说创建一个linux防火墙，他可以为整个网络和所有的网 络操作系统提供SYN COOKIE保护你可以用这个防火墙来阻断半开放式tcp连接，所以这个受保护的系统不会进入半开放状态(TCP_SYN_RECV)。当 连接完全建立的时候，客户机到服务器的连接要通过防火墙来中转完成。 二：什么是SYN洪水攻击？（来自CERT的警告） 当一个系统（我们叫他客户端）尝试和一个提供了服务的系统（服务器）建立TCP连接，C和服务端会交换一系列报文。 这种连接技术广泛的应用在各种TCP连接中，例如telnet,Web,email,等等。 首先是C发送一个SYN报文给服务端，然后这个服务端发送一个SYN-ACK包以回应C，接着，C就返回一个ACK包来实现一次完 整的TCP连接。就这样，C到服务端的连接就建立了，这时C和服务端就可以互相交换数据了。下面是上文的图片说明：） Client Server ------ ------ SYN--------------------&gt; &lt;--------------------SYN-ACK ACK--------------------&gt; Client and server can now send service-specific data 在S返回一个确认的SYN-ACK包的时候有个潜在的弊端，他可能不会接到C回应的ACK包。这个也就是所谓的半开放连接，S需要 耗费一定的数量的系统内存来等待这个未决的连接，虽然这个数量是受限的，但是恶意者可以通过创建很多的半开放式连接来发动SYN洪水攻击 。通过ip欺骗可以很容易的实现半开放连接。攻击者发送SYN包给受害者系统，这个看起来是合法的，但事实上所谓的C根本不会回应这个 。SYN-ACK报文，这意味着受害者将永远不会接到ACK报文。 而此时，半开放连接将最终耗用受害者所有的系统资源，受害者将不能再接收任何其他的请求。通常等待ACK返回包有超时限制，所以半开放 。连接将最终超时，而受害者系统也会自动修复。虽然这样，但是在受害者系统修复之前，攻击者可以很容易的一直发送虚假的SYN请求包来持续 攻击。 在大多数情况下，受害者几乎不能接受任何其他的请求，但是这种攻击不会影响到已经存在的进站或者是出站连接。虽然这样，受害者系统 还是可能耗尽系统资源，以导致其他种种问题。 攻击系统的位置几乎是不可确认的，因为SYN包中的源地址多数都是虚假的。当SYN包到达受害者系统的时候，没有办法找到他的真实地址 ，因为在基于源地址的数据包传输中，源ip过滤是唯一可以验证数据包源的方法。 三：什么是SYN cookie？ SYN cookie就是用一个cookie来响应TCP SYN请求的TCP实现，根据上面的描述，在正常的TCP实现中，当S接收到一个SYN数据包，他返回 一个SYN-ACK包来应答，然后进入TCP-SYN-RECV（半开放连接）状态来等待最后返回的ACK包。S用一个数据空间来描述所有未决的连接， 然而这个数据空间的大小是有限的，所以攻击者将塞满这个空间。 在TCP SYN COOKIE的执行过程中，当S接收到一个SYN包的时候，他返回一个SYN-ACK包，这个数据包的ACK序列号是经过加密的，也就 是说，它由源地址，端口源次序，目标地址，目标端口和一个加密种子计算得出。然后S释放所有的状态。如果一个ACK包从C返回， S将重新计算它来判断它是不是上个SY 终止连接 采用四次挥手断开双向连接。（1） TCP客户端发送一个FIN，用来关闭客户到服务器的数据传送。（2） 服务器收到这个FIN，它发回一个ACK，确认序号为收到的序号加1。和SYN一样，一个FIN将占用一个序号。（3） 服务器关闭客户端的连接，发送一个FIN给客户端。（4） 客户端发回ACK报文确认，并将确认序号设置为收到序号加1。 客户端的状态可以用一下流程图来表示： CLOSED-&gt;SYN_SENT-&gt;ESTABLISHED-&gt;FIN_WAIT_1-&gt;FIN_WAIT_2-&gt;TIME_WAIT-&gt;CLOSED 服务器的状态可以流程图： CLOSED-&gt;LISTEN-&gt;SYN收到 -&gt;ESTABLISHED-&gt;CLOSE_WAIT-&gt;LAST-&gt;ACK-&gt;CLOSED","categories":[],"tags":[{"name":"TCP/IP","slug":"TCP-IP","permalink":"https://leehave.github.io/tags/TCP-IP/"}]},{"title":"模块化开发和面向对象编程","slug":"模块化&面向对象编程","date":"2017-01-07T09:38:51.000Z","updated":"2017-01-07T09:38:51.000Z","comments":true,"path":"2017/01/07/模块化&面向对象编程/","link":"","permalink":"https://leehave.github.io/2017/01/07/模块化&面向对象编程/","excerpt":"demo放在coding上 https://coding.net/u/coder-lzx/p/seajsdemo/git 一开始团队做项目,都会从简单的习惯开始。通常会把一些通用的功能抽取出来。独立成一个一个的函数。比如 1234567function each(arr) &#123; // 实现代码&#125;function log(str) &#123; // 实现代码&#125; 并像模像样地把这些函数统一放在 util.js 里。需要用到时，引入该文件就行。这一切工作得很好。 慢慢的项目完成后,后端同志也加了代码,一些原本可以公共代码可以复用的,结果又重新加上去了,重复的造轮子。就像这样 这就尴尬了,为了避免重复造轮子,面向对象的设计模式解决了这种情况,有个好处就是利于多人协作。 调用方法","text":"demo放在coding上 https://coding.net/u/coder-lzx/p/seajsdemo/git 一开始团队做项目,都会从简单的习惯开始。通常会把一些通用的功能抽取出来。独立成一个一个的函数。比如 1234567function each(arr) &#123; // 实现代码&#125;function log(str) &#123; // 实现代码&#125; 并像模像样地把这些函数统一放在 util.js 里。需要用到时，引入该文件就行。这一切工作得很好。 慢慢的项目完成后,后端同志也加了代码,一些原本可以公共代码可以复用的,结果又重新加上去了,重复的造轮子。就像这样 这就尴尬了,为了避免重复造轮子,面向对象的设计模式解决了这种情况,有个好处就是利于多人协作。 调用方法 seajs作为一个已停止更新维护的项目,我暂时就不去过多学习,前端的水深,需要无时无刻的学习和关注动态。致此,一年过去了,继续努力","categories":[],"tags":[{"name":"seajs","slug":"seajs","permalink":"https://leehave.github.io/tags/seajs/"},{"name":"设计模式","slug":"设计模式","permalink":"https://leehave.github.io/tags/设计模式/"},{"name":"停止维护的一个模块化工具","slug":"停止维护的一个模块化工具","permalink":"https://leehave.github.io/tags/停止维护的一个模块化工具/"}]},{"title":"常用js函数","slug":"常用js函数","date":"2016-11-04T05:15:19.000Z","updated":"2016-11-04T05:15:19.000Z","comments":true,"path":"2016/11/04/常用js函数/","link":"","permalink":"https://leehave.github.io/2016/11/04/常用js函数/","excerpt":"Ajax请求jquery ajax函数 我自己封装了一个ajax的函数，代码如下： 1234567891011121314151617181920var Ajax = function(url, type success, error) &#123; $.ajax(&#123; url: url, type: type, dataType: &apos;json&apos;, timeout: 10000, success: function(d) &#123; var data = d.data; success &amp;&amp; success(data); &#125;, error: function(e) &#123; error &amp;&amp; error(e); &#125; &#125;); &#125;;// 使用方法：Ajax(&apos;/data.json&apos;, &apos;get&apos;, function(data) &#123; console.log(data); &#125;);jsonp方式","text":"Ajax请求jquery ajax函数 我自己封装了一个ajax的函数，代码如下： 1234567891011121314151617181920var Ajax = function(url, type success, error) &#123; $.ajax(&#123; url: url, type: type, dataType: &apos;json&apos;, timeout: 10000, success: function(d) &#123; var data = d.data; success &amp;&amp; success(data); &#125;, error: function(e) &#123; error &amp;&amp; error(e); &#125; &#125;); &#125;;// 使用方法：Ajax(&apos;/data.json&apos;, &apos;get&apos;, function(data) &#123; console.log(data); &#125;);jsonp方式 有时候我们为了跨域，要使用jsonp的方法，我也封装了一个函数： 1234567891011121314151617181920212223242526272829303132function jsonp(config) &#123; var options = config || &#123;&#125;; // 需要配置url, success, time, fail四个属性 var callbackName = (&apos;jsonp_&apos; + Math.random()).replace(&quot;.&quot;, &quot;&quot;); var oHead = document.getElementsByTagName(&apos;head&apos;)[0]; var oScript = document.createElement(&apos;script&apos;); oHead.appendChild(oScript); window[callbackName] = function(json) &#123; //创建jsonp回调函数 oHead.removeChild(oScript); clearTimeout(oScript.timer); window[callbackName] = null; options.success &amp;&amp; options.success(json); //先删除script标签，实际上执行的是success函数 &#125;; oScript.src = options.url + &apos;?&apos; + callbackName; //发送请求 if (options.time) &#123; //设置超时处理 oScript.timer = setTimeout(function () &#123; window[callbackName] = null; oHead.removeChild(oScript); options.fail &amp;&amp; options.fail(&#123; message: &quot;超时&quot; &#125;); &#125;, options.time); &#125; &#125;;// 使用方法：jsonp(&#123; url: &apos;/b.com/b.json&apos;, success: function(d)&#123; //数据处理 &#125;, time: 5000, fail: function()&#123; //错误处理 &#125; &#125;); 常用正则验证表达式手机号验证 1234var validate = function(num) &#123; var exp = /^1[3-9]\\d&#123;9&#125;$/; return exp.test(num); &#125;; 身份证号验证 12345var exp = /^[1-9]&#123;1&#125;[0-9]&#123;14&#125;$|^[1-9]&#123;1&#125;[0-9]&#123;16&#125;([0-9]|[xX])$/;ip验证var exp = /^(\\d&#123;1,2&#125;|1\\d\\d|2[0-4]\\d|25[0-5])\\.(\\d&#123;1,2&#125;|1\\d\\d|2[0-4]\\d|25[0-5])\\.(\\d&#123;1,2&#125;|1\\d\\d|2[0-4]\\d|25[0-5])\\.(\\d&#123;1,2&#125;|1\\d\\d|2[0-4]\\d|25[0-5])$/;常用js函数 返回顶部 1234567891011$(window).scroll(function() &#123; var a = $(window).scrollTop(); if(a &gt; 100) &#123; $(&apos;.go-top&apos;).fadeIn(); &#125;else &#123; $(&apos;.go-top&apos;).fadeOut(); &#125; &#125;);$(&quot;.go-top&quot;).click(function()&#123; $(&quot;html,body&quot;).animate(&#123;scrollTop:&quot;0px&quot;&#125;,&apos;600&apos;); &#125;); 阻止冒泡 12345678function stopBubble(e)&#123; e = e || window.event; if(e.stopPropagation)&#123; e.stopPropagation(); //W3C阻止冒泡方法 &#125;else &#123; e.cancelBubble = true; //IE阻止冒泡方法 &#125; &#125; 全部替换replaceAll 1234var replaceAll = function(bigStr, str1, str2) &#123; //把bigStr中的所有str1替换为str2 var reg = new RegExp(str1, &apos;gm&apos;); return bigStr.replace(reg, str2); &#125; 获取浏览器url中的参数值 123var getURLParam = function(name) &#123; return decodeURIComponent((new RegExp(&apos;[?|&amp;]&apos; + name + &apos;=&apos; + &apos;([^&amp;;]+?)(&amp;|#|;|$)&apos;, &quot;ig&quot;).exec(location.search) || [, &quot;&quot;])[1].replace(/\\+/g, &apos;%20&apos;)) || null; &#125;; 深度拷贝对象 12345678910111213function cloneObj(obj) &#123; var o = obj.constructor == Object ? new obj.constructor() : new obj.constructor(obj.valueOf()); for(var key in obj)&#123; if(o[key] != obj[key] )&#123; if(typeof(obj[key]) == &apos;object&apos; )&#123; o[key] = mods.cloneObj(obj[key]); &#125;else&#123; o[key] = obj[key]; &#125; &#125; &#125; return o; &#125; 数组去重 12345678910var unique = function(arr) &#123; var result = [], json = &#123;&#125;; for (var i = 0, len = arr.length; i &lt; len; i++)&#123; if (!json[arr[i]]) &#123; json[arr[i]] = 1; result.push(arr[i]); //返回没被删除的元素 &#125; &#125; return result; &#125;; 判断数组元素是否重复 12345678var isRepeat = function(arr) &#123; //arr是否有重复元素 var hash = &#123;&#125;; for (var i in arr) &#123; if (hash[arr[i]]) return true; hash[arr[i]] = true; &#125; return false; &#125;; 生成随机数 123function randombetween(min, max)&#123; return min + (Math.random() * (max-min +1)); &#125; 操作cookie 12345678910111213141516own.setCookie = function(cname, cvalue, exdays)&#123; var d = new Date(); d.setTime(d.getTime() + (exdays*24*60*60*1000)); var expires = &apos;expires=&apos;+d.toUTCString(); document.cookie = cname + &apos;=&apos; + cvalue + &apos;; &apos; + expires; &#125;;own.getCookie = function(cname) &#123; var name = cname + &apos;=&apos;; var ca = document.cookie.split(&apos;;&apos;); for(var i=0; i&lt; ca.length; i++) &#123; var c = ca[i]; while (c.charAt(0) == &apos; &apos;) c = c.substring(1); if (c.indexOf(name) != -1) return c.substring(name.length, c.length); &#125; return &apos;&apos;; &#125;; 知识技巧总结数据类型 1underfined、null、0、false、NaN、空字符串。他们的逻辑非结果均为true。 闭包格式 好处：避免命名冲突（全局变量污染）。 123(function(a, b) &#123; console.log(a+b); //30 &#125;)(10, 20); 截取和清空数组 123var arr = [12, 222, 44, 88];arr.length = 2; //截取，arr = [12, 222]; arr.length = 0; //清空，arr will be equal to []. 获取数组的最大最小值 123var numbers = [5, 45822, 120, -215];var maxInNumbers = Math.max.apply(Math, numbers); //45822var minInNumbers = Math.min.apply(Math, numbers); //-215 浮点数计算问题 10.1 + 0.2 == 0.3 //false 为什么呢？因为0.1+0.2等于0.30000000000000004。JavaScript的数字都遵循IEEE 754标准构建，在内部都是64位浮点小数表示。可以通过使用toFixed()来解决这个问题。 数组排序sort函数 1234567891011121314151617181920212223var arr = [1, 5, 6, 3]; //数字数组arr.sort(function(a, b) &#123; return a - b; //从小到大排 return b - a; //从大到小排 return Math.random() - 0.5; //数组洗牌 &#125;);var arr = [&#123; //对象数组 num: 1, text: &apos;num1&apos; &#125;, &#123; num: 5, text: &apos;num2&apos; &#125;, &#123; num: 6, text: &apos;num3&apos; &#125;, &#123; num: 3, text: &apos;num4&apos; &#125;]; arr.sort(function(a, b) &#123; return a.num - b.num; //从小到大排 return b.num - a.num; //从大到小排 &#125;); 对象和字符串的转换 123var obj = &#123;a: &apos;aaa&apos;, b: &apos;bbb&apos;&#125;;var objStr = JSON.stringify(obj); // &quot;&#123;&quot;a&quot;:&quot;aaa&quot;,&quot;b&quot;:&quot;bbb&quot;&#125;&quot;var newObj = JSON.parse(objStr); // &#123;a: &quot;aaa&quot;, b: &quot;bbb&quot;&#125; git笔记git使用之前的配置 git config --global user.email xxx@163.com git config --global user.name xxx ssh-keygen -t rsa -C xxx@163.com(邮箱地址) // 生成ssh 找到 .ssh 文件夹打开，使用 cat id_rsa.pub //打开公钥ssh串 登陆 github，settings － SSH keys － add ssh keys （把上面的内容全部添加进去即可）说明：然后这个邮箱（xxxxx@gmail.com）对应的账号在github上就有权限对仓库进行操作了。可以尽情的进行下面的git命令了。git常用命令 git config user.name / user.email //查看当前git的用户名称、邮箱 git clone https://github.com/jarson7426/javascript.git project //clone仓库到本地。 修改本地代码，提交到分支: git add file / git commit -m “新增文件” 把本地库推送到远程库: git push origin master 查看提交日志：git log -5 返回某一个版本：git reset --hard 123 分支：git branch / git checkout name / git checkout -b dev 合并name分支到当前分支：git merge name / git pull origin 删除本地分支：git branch -D name 删除远程分支： git push origin :daily/x.x.x git checkout -b mydev origin/daily/1.0.0 //把远程daily分支映射到本地mydev分支进行开发 合并远程分支到当前分支 git pull origin daily/1.1.1 发布到线上： git tag publish/0.1.5 git push origin publish/0.1.5:publish/0.1.5 14、线上代码覆盖到本地： git checkout --theirs build/scripts/ddos git checkout --theirs src/app/ddos","categories":[],"tags":[{"name":"函数 总结","slug":"函数-总结","permalink":"https://leehave.github.io/tags/函数-总结/"}]},{"title":"javascript面试题","slug":"几道面试题","date":"2016-10-09T07:43:24.000Z","updated":"2016-10-09T07:43:24.000Z","comments":true,"path":"2016/10/09/几道面试题/","link":"","permalink":"https://leehave.github.io/2016/10/09/几道面试题/","excerpt":"这些题目是考察JavaScript函数的基本概念内容 1.以下所有示例都会弹出 &quot;Boo&quot;警告窗,您能解释其中的原因吗?123456789101112131415var f = alert;eval(&apos;f(&quot;Boo!&quot;)&apos;);undefined//2var e;var f = alert;eval(&apos;e=f&apos;)(&apos;Boo&apos;);undefined//3(function()&#123; return alert;&#125;)()(&apos;Boo&apos;)","text":"这些题目是考察JavaScript函数的基本概念内容 1.以下所有示例都会弹出 &quot;Boo&quot;警告窗,您能解释其中的原因吗?123456789101112131415var f = alert;eval(&apos;f(&quot;Boo!&quot;)&apos;);undefined//2var e;var f = alert;eval(&apos;e=f&apos;)(&apos;Boo&apos;);undefined//3(function()&#123; return alert;&#125;)()(&apos;Boo&apos;) 2.下面代码中,alert()弹出的内容会是什么?a = 1;12345678function f() &#123; var a = 2; function n() &#123; alert(a); &#125; n();&#125;f(); 3.如果在控制台中执行以下各行,分别会输出什么内容?12345parseInt(&apos;lel&apos;)parseFloat(&apos;lel&apos;)isFinite(0/10)isFinite(20/0)isNaN(parseInt(NaN))","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://leehave.github.io/tags/JavaScript/"}]},{"title":"vuejs结构分析","slug":"vue构建项目结构解析","date":"2016-09-05T15:27:09.000Z","updated":"2016-09-05T15:27:09.000Z","comments":true,"path":"2016/09/05/vue构建项目结构解析/","link":"","permalink":"https://leehave.github.io/2016/09/05/vue构建项目结构解析/","excerpt":"Vue.js是一个构建数据驱动的 web 界面的库。Vue.js 的目标是通过尽可能简单的 API 实现响应的数据绑定和组合的视图组件。其实还是后端玩的那套,只不过借以用之 下面我们来看下vue的VM层结构 文档结构如下 APP是单页起始的父组件模板 其余子组件全部在 conponents文件夹中","text":"Vue.js是一个构建数据驱动的 web 界面的库。Vue.js 的目标是通过尽可能简单的 API 实现响应的数据绑定和组合的视图组件。其实还是后端玩的那套,只不过借以用之 下面我们来看下vue的VM层结构 文档结构如下 APP是单页起始的父组件模板 其余子组件全部在 conponents文件夹中 文档引入如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;template&gt; &lt;div class=&quot;goods-container&quot;&gt; &lt;goods-top-box&gt;&lt;/goods-top-box&gt; &lt;goods-collocation&gt;&lt;/goods-collocation&gt; &lt;goods-accessories&gt;&lt;/goods-accessories&gt; &lt;goods-around&gt;&lt;/goods-around&gt; &lt;recommend&gt;&lt;/recommend&gt; &lt;hot-product&gt;&lt;/hot-product&gt; &lt;goods-content&gt;&lt;/goods-content&gt; &lt;video&gt;&lt;/video&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import GoodsTopBox from &apos;./GoodsTopBox&apos;import GoodsCollocation from &apos;./GoodsCollocation&apos;import GoodsAccessories from &apos;./GoodsAccessories&apos;import GoodsAround from &apos;./GoodsAround&apos;import Recommend from &apos;./Recommend&apos;import HotProduct from &apos;./HotProduct&apos;import GoodsContent from &apos;./GoodsContent&apos;import Video from &apos;./Video&apos;vueexport default &#123; components: &#123; &apos;goods-top-box&apos;: GoodsTopBox, &apos;goods-collocation&apos;: GoodsCollocation, &apos;goods-accessories&apos;: GoodsAccessories, &apos;goods-around&apos;: GoodsAround, &apos;recommend&apos;: Recommend, &apos;hot-product&apos;: HotProduct, &apos;goods-content&apos;: GoodsContent, &apos;video&apos;: Video &#125;&#125;&lt;/script&gt;&lt;style&gt;.goods-container &#123; width: 100%; height: auto; background: #f5f5f5; padding-bottom: 40px;&#125;&lt;/style&gt; 我们再看看这个控制台显示 我们用Google扩展工具vue-devtools工具 我们不难发现 一些公共组件都放在common里面 例如slide之类的子组件 可以使用 v-for 指令基于一个数组渲染一个列表。 这个指令使用特殊的语法，形式为 item in items，items 是数据数组，item 是当前数组元素的别名,DOM都由前端渲染生成,后端只需传递数据,无需再有前端模板和逻辑,后端语言混淆,我们只需要改变VM结构,便不再像传统非MVVM一样去手动修改完逻辑又去修改DOM结构。用来开发移动端更方便管理应用状态，组件解耦，多人组件共享等等(正在摸索,以前用MUI,SUI之类的jqery库主导的UI库)。下面来看看v-for如何渲染DOM层 1234567891011121314&lt;template&gt; &lt;div class=&quot;product-container&quot;&gt; &lt;goods-header :title=&quot;title&quot;&gt;&lt;/goods-header&gt; &lt;div class=&quot;box-bd&quot;&gt; &lt;ul class=&quot;content-list clearfix&quot;&gt; &lt;li&gt; &lt;template v-for=&quot;content in contents&quot;&gt; &lt;good-content-slide :content=&quot;content&quot;&gt;&lt;/good-content-slide&gt; &lt;/template&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt; 数据层json传递数据123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;script&gt;import GoodsHeader from &apos;./common/GoodsHeader&apos;import GoodsContentSlide from &apos;./common/GoodsContentSlide&apos;export default &#123; data () &#123; return &#123; currPage: 0, title: &apos;内容&apos;, contents: [ &#123; title: &apos;图书&apos;, type: &apos;book&apos;, list: [ &#123;sourceUrl: &apos;http://www.duokan.com/book/115222&apos;, title: &apos;哈利·波特与魔法石&apos;, desc: &apos;哈利波特来了&apos;, imgUrl: &apos;//i3.mifile.cn/a4/8e3584b6-3169-41c6-9356-939ec79aac2b&apos;, type: 0&#125;, &#123;sourceUrl: &apos;http://www.duokan.com/special/7812&apos;, title: &apos;特价专区&apos;, desc: &apos;精选畅销好书，特价促销，天天更新，天天特价！&apos;, price: &apos;限时优惠&apos;, imgUrl: &apos;//i3.mifile.cn/a4/T1dlVgBbbT1RXrhCrK.jpg&apos;, type: 1&#125;, &#123;sourceUrl: &apos;http://www.duokan.com/list/9-1&apos;, title: &apos;杂志专区&apos;, desc: &apos;纸媒杂志＋互联网杂志，你想看的这都有！&apos;, price: &apos;同步新刊上线&apos;, imgUrl: &apos;//i3.mifile.cn/a4/T1R3WgBjKT1RXrhCrK.jpg&apos;, type: 1&#125;, &#123;sourceUrl: &apos;http://www.duokan.com/list/1-1?from=xiaomi&apos;, desc1: &apos;海量好书，享受精品阅读时光&apos;, desc2: &apos;漂亮的中文排版，千万读者选择！&apos;, btnTxt: &apos;前往多看阅读&apos;, price: &apos;限时优惠&apos;, imgUrl: &apos;//s01.mifile.cn/i/index/more-duokan.jpg&apos;, type: 2&#125; ] &#125;, &#123; title: &apos;MIUI主题&apos;, type: &apos;theme&apos;, list: [ &#123;sourceUrl: &apos;http://zhuti.xiaomi.com/detail/4ecf4ebb-7cba-4142-96aa-6b8deb2426ef&apos;, title: &apos;新世纪福音战士OL&apos;, desc: &apos;EVA手游正版授权，同名主题，高能来袭！&apos;, price: &apos;免费&apos;, imgUrl: &apos;http://i3.mifile.cn/a4/7d47dde1-60fb-4ff3-8fa1-364cfc452457&apos;, type: 1&#125;, &#123;sourceUrl: &apos;http://zhuti.xiaomi.com/detail/d6277519-ca46-420c-ab09-060f6d293f94&apos;, title: &apos;世界就在这里&apos;, desc: &apos;“青春的世界里，每一刻都要用尽全力欢呼”&apos;, price: &apos;免费&apos;, imgUrl: &apos;http://i3.mifile.cn/a4/b2c8ca37-4ba8-4af8-b87e-91847980a278&apos;, type: 1&#125;, &#123;sourceUrl: &apos;http://zhuti.xiaomi.com/detail/13df18d4-e52c-4a61-82e3-97014f21bd77&apos;, title: &apos;不悔剑三&apos;, desc: &apos;精品剑网三同人主题 浪漫武侠 共闯天涯&apos;, price: &apos;3米币&apos;, imgUrl: &apos;http://i3.mifile.cn/a4/10af68f9-3012-48bb-85b1-ad3b0646dfdb&apos;, type: 1&#125;, &#123;sourceUrl: &apos;http://zhuti.xiaomi.com/?from=mi&apos;, desc1: &apos;众多个性主题、百变锁屏与自由桌面&apos;, desc2: &apos;让你的手机与众不同！&apos;, btnTxt: &apos;前往MIUI主题市场&apos;, price: &apos;限时优惠&apos;, imgUrl: &apos;//s01.mifile.cn/i/index/more-duokan.jpg&apos;, type: 2&#125; ] &#125;, &#123; title: &apos;游戏&apos;, type: &apos;game&apos;, list: [ &#123;sourceUrl: &apos;http://ljm.mi.com/?channel=meng_1084_1_android&apos;, title: &apos;老九门&apos;, desc: &apos;盗墓笔记前传上线&apos;, price: &apos;免费&apos;, imgUrl: &apos;http://i3.mifile.cn/a4/6032cb36-587f-4366-89ef-aefed2546552&apos;, type: 1&#125;, &#123;sourceUrl: &apos;http://game.xiaomi.com/miyou/index.html&apos;, title: &apos;米柚手游模拟器&apos;, desc: &apos;在电脑上玩遍小米所有手游&apos;, price: &apos;免费&apos;, imgUrl: &apos;//i3.mifile.cn/a4/T1czW_BXCv1R4cSCrK.png&apos;, type: 1&#125;, &#123;sourceUrl: &apos;http://game.xiaomi.com/app-appdetail--app_id__581412.html&apos;, title: &apos;剑侠情缘&apos;, desc: &apos;玩剑侠情缘手游，领666壕礼！！&apos;, price: &apos;免费&apos;, imgUrl: &apos;http://i3.mifile.cn/a4/010948ae-bd48-49c6-af12-4ec8c4a0c829&apos;, type: 1&#125;, &#123;sourceUrl: &apos;http://game.xiaomi.com/index.php?c=index&amp;a=run&apos;, desc1: &apos;免费下载海量的手机游戏&apos;, desc2: &apos;天天都有现金福利赠送&apos;, btnTxt: &apos;前往小米游戏商店&apos;, price: &apos;限时优惠&apos;, imgUrl: &apos;//s01.mifile.cn/i/index/more-game.jpg&apos;, type: 2&#125; ] &#125;, &#123; title: &apos;应用&apos;, type: &apos;app&apos;, list: [ &#123;sourceUrl: &apos;http://app.mi.com/subject/168797&apos;, title: &apos;2015年度应用&apos;, desc: &apos;2015年度应用&apos;, price: &apos;免费&apos;, imgUrl: &apos;//i3.mifile.cn/a4/T1YyJgBCYv1R4cSCrK.png&apos;, type: 1&#125;, &#123;sourceUrl: &apos;http://app.mi.com/subject/168798&apos;, title: &apos;2015年度游戏&apos;, desc: &apos;2015年度游戏&apos;, price: &apos;免费&apos;, imgUrl: &apos;//i3.mifile.cn/a4/T1eaxgB4Ev1R4cSCrK.png&apos;, type: 1&#125;, &#123;sourceUrl: &apos;http://app.mi.com/subject/167924&apos;, title: &apos;小米应用&apos;, desc: &apos;小米出品 必属精品&apos;, price: &apos;免费&apos;, imgUrl: &apos;//i3.mifile.cn/a4/T15VZvB5Kv1R4cSCrK.png&apos;, type: 1&#125;, &#123;sourceUrl: &apos;http://app.mi.com/?from=mi&apos;, desc1: &apos;帮助小米手机和其他安卓手机用户&apos;, desc2: &apos;发现好用的安卓应用&apos;, btnTxt: &apos;前往小米应用商店&apos;, price: &apos;限时优惠&apos;, imgUrl: &apos;//s01.mifile.cn/i/index/more-app.jpg&apos;, type: 2&#125; ] &#125;] &#125; &#125;, components: &#123; &apos;goods-header&apos;: GoodsHeader, &apos;good-content-slide&apos;: GoodsContentSlide &#125;&#125;&lt;/script&gt; 这样的前后端分离,效率是不是提高了很多!","categories":[],"tags":[{"name":"解析","slug":"解析","permalink":"https://leehave.github.io/tags/解析/"}]},{"title":"vue开发环境设置","slug":"开发环境设置","date":"2016-09-05T06:31:01.000Z","updated":"2016-09-05T06:31:01.000Z","comments":true,"path":"2016/09/05/开发环境设置/","link":"","permalink":"https://leehave.github.io/2016/09/05/开发环境设置/","excerpt":"Vue.js 不支持 IE8 及其以下版本，因为 Vue.js 使用了 IE8 不能实现的 ECMAScript 5 特性。 Vue.js 支持所有兼容 ECMAScript 5 的浏览器。 编辑工具：atom，64位。 安装过程 解压 atom.zip 文件夹到自己的工具盘下。 修改atom快捷方式中的路径为自己工具盘的路径。 配置过程 解压.atom.rar 到自己机器的当前用户的根目录下。这个文件夹是atom的使用配置文件，包括： git-plus插件：git插件 language-vue: vue组件开发语法加亮 linter: 语法检查插件 linter-eslint：对js文件、vue组件进行语法检查的插件 snippets.cson文件：内置了一些vue组件的代码片段","text":"Vue.js 不支持 IE8 及其以下版本，因为 Vue.js 使用了 IE8 不能实现的 ECMAScript 5 特性。 Vue.js 支持所有兼容 ECMAScript 5 的浏览器。 编辑工具：atom，64位。 安装过程 解压 atom.zip 文件夹到自己的工具盘下。 修改atom快捷方式中的路径为自己工具盘的路径。 配置过程 解压.atom.rar 到自己机器的当前用户的根目录下。这个文件夹是atom的使用配置文件，包括： git-plus插件：git插件 language-vue: vue组件开发语法加亮 linter: 语法检查插件 linter-eslint：对js文件、vue组件进行语法检查的插件 snippets.cson文件：内置了一些vue组件的代码片段 使用方式 atom 主要使用快捷键，文档参考： atom快捷键 官方使用手册 文档编写使用markdown，文档参考： markdown语言详解 开发工具：nodejs，64位 安装过程 解压 nodejs.rar 文件夹到自己的工具盘下。 设置系统环境变量Path，把nodejs安装的根目录添加进去。 命令行下运行npm, 可以看到使用帮助，证明成功。 配置过程 解压 npm.rar 到自己机器当前用户的AppData\\Roaming文件夹下。AppData文件夹是系统隐藏文件夹，如找不到，设置显示隐藏文件夹即可。npm文件夹中有全局模块，可以在所有项目里共享。 使用发生 npm 要在命令行下运行，文档参考： npm使用 Git工具 安装过程 解压 git.rar 文件夹到自己的工具盘下。 设置系统环境变量Path，内容为 安装路径/git/cmd 命令行下运行git, 可以看到使用帮助，证明成功。 配置过程 复制.gitconfig文件到$HOME下。 chrome安装 安装过程 解压chrome.rar到自己的工具盘下。 运行Chrome\\Application\\chrome.exe 解压vue-devtools.rar到自己的工具盘下 在chrome的 更多工具\\扩展程序 里，选择 开发模式，点击 已解压的扩展程序，选择vue-devtools解压处理的文件夹即可。安装的是vue的chrome扩展工具。 vue-client工程，前台vue组件的基础工程 安装过程 在github上下载最新版本到自己的工作区间。命令如下： 1git clone https://github.com/DuBin1988/vue-client 在atom里 File/Add Project Folder 菜单中加入vue-client工程 解压vue-client\\node_modules.rar 到vue-client目录下，这个文件是vue-client的本地模块文件夹 测试 修改examples下所有文件名首字母为大写 在命令行下，进入vue-client目录 运行 npm run dev 启动测试 在chrome里执行 http://localhost:8080/Busy.html 测试busy组件是否正常运行。 按 F12 打开chrome的开发者环境，可以看到vue-Devtools，用这个工具，可以看到组件树。 自己动手 复制examples下的Busy文件夹，改名为Test 修改index.html &lt;script src=&quot;../BusyApp.js&quot;&gt;&lt;/script&gt;中 BusyApp 为 TestApp main.js保持不动。 App.vue是自己要做的组件，修改组件模板部分为自己想要的内容。重启 npm run dev，访问 http://localhost:8080/Test.html，即可看到自己所做的组件。 更多内容 组件制作请参考：http://cn.vuejs.org/ JS6请参考：http://es6.ruanyifeng.com/ BootStrap请参考：http://v3.bootcss.com/ 工作规范一般情况下，遵循如下工作规范： 在docs里对要开发的组件，进行设计及说明，格式可以参考Busy.md等文件。 开发的组件，放在src/components下。 在examples下建立文件夹，对开发的组件进行测试。 提交前，对docs及组件源码进行检查，确定是否最终内容。 在进行新版本发布时，修改CHANGELOG.md，CHANGELOG.md书写规范，参考：http://keepachangelog.com/zh-CN/ vue-client下的README.md是vue-client的整体描述。","categories":[],"tags":[{"name":"MVVM","slug":"MVVM","permalink":"https://leehave.github.io/tags/MVVM/"},{"name":"vuejs","slug":"vuejs","permalink":"https://leehave.github.io/tags/vuejs/"}]},{"title":"前端开发面试题之JavaScript","slug":"前端开发面试题之JavaScript","date":"2016-08-04T05:54:55.000Z","updated":"2016-08-04T05:54:55.000Z","comments":true,"path":"2016/08/04/前端开发面试题之JavaScript/","link":"","permalink":"https://leehave.github.io/2016/08/04/前端开发面试题之JavaScript/","excerpt":"原作者晓松链接 http://www.jianshu.com/p/05d84b60a1dc “每18至24个月，前端都会难一倍” ——赫门 “2015深JS大会《前端服务化之路》主题演讲” 知识点数据类型、运算、对象、function、继承、闭包、作用域、原型链、事件、RegExp、JSON、Ajax、DOM、BOM、内存泄漏、跨域、异步加载、模板引擎、前端MVC、前端MVVM、路由、模块化、Canvas、jQuery、ECMAScript 2015（ES6）、Node.js、AngularJS、React、CommonJS、AMD、CMD ……","text":"原作者晓松链接 http://www.jianshu.com/p/05d84b60a1dc “每18至24个月，前端都会难一倍” ——赫门 “2015深JS大会《前端服务化之路》主题演讲” 知识点数据类型、运算、对象、function、继承、闭包、作用域、原型链、事件、RegExp、JSON、Ajax、DOM、BOM、内存泄漏、跨域、异步加载、模板引擎、前端MVC、前端MVVM、路由、模块化、Canvas、jQuery、ECMAScript 2015（ES6）、Node.js、AngularJS、React、CommonJS、AMD、CMD …… 题目&amp;答案 介绍一下 JS 的基本数据类型。 1Undefined、Null、Boolean、Number、String 介绍一下 JS 有哪些内置对象。 123Object 是 JavaScript 中所有对象的父对象数据封装类对象：Object、Array、Boolean、Number、String其他对象：Function、Argument、Math、Date、RegExp、Error 列举几条 JavaScript 的基本代码规范。 12345678910111213141516171819（1）不要在同一行声明多个变量（2）如果你不知道数组的长度，使用 push（3）请使用 ===/!== 来比较 true/false 或者数值（4）对字符串使用单引号 &apos;&apos;(因为大多时候我们的字符串。特别html会出现&quot;)（5）使用对象字面量替代 new Array 这种形式（6）绝对不要在一个非函数块里声明一个函数，把那个函数赋给一个变量。浏览器允许你这么做，但是它们解析不同（7）不要使用全局函数（8）总是使用 var 来声明变量，如果不这么做将导致产生全局变量，我们要避免污染全局命名空间（9）Switch 语句必须带有 default 分支（10）使用 /**...*/ 进行多行注释，包括描述，指定类型以及参数值和返回值（11）函数不应该有时候有返回值，有时候没有返回值（12）语句结束一定要加分号（13）for 循环必须使用大括号（14）if 语句必须使用大括号（15）for-in 循环中的变量应该使用 var 关键字明确限定作用域，从而避免作用域污染（16）避免单个字符名，让你的变量名有描述意义（17）当命名对象、函数和实例时使用驼峰命名规则（18）给对象原型分配方法，而不是用一个新的对象覆盖原型，覆盖原型会使继承出现问题（19）当给事件附加数据时，传入一个哈希而不是原始值，这可以让后面的贡献者加入更多数据到事件数据里，而不用找出并更新那个事件的事件处理器 介绍一下 JavaScript 原型，原型链，它们有何特点？ 1234567891011121314151617每个对象都会在其内部初始化一个属性，就是prototype(原型)，当我们访问一个对象的属性时，如果这个对象内部不存在这个属性，那么他就会去prototype里找这个属性，这个prototype又会有自己的prototype，于是就这样一直找下去，也就是我们平时所说的原型链的概念。关系：instance.constructor.prototype = instance.__proto__//特点：JavaScript对象是通过引用来传递的，我们创建的每个新对象实体中并没有一份属于自己的原型副本，当我们修改原型时，与之相关的对象也会继承这一改变。//当我们需要一个属性时，JavaScript引擎会先看当前对象中是否有这个属性，如果没有的话，就会查找它的prototype对象是否有这个属性，如此递推下去，一致检索到Object内建对象。function Func()&#123;&#125;Func.prototype.name = &quot;Xiaosong&quot;;Func.prototype.getInfo = function() &#123; return this.name;&#125;var person = new Func();console.log(person.getInfo());//&quot;Xiaosong&quot;console.log(Func.prototype);//Func &#123; name = &quot;Xiaosong&quot;, getInfo = function() &#125; JavaScript 有几种类型的值？能否画一下它们的内存图？ 123456栈：原始数据类型（Undefined，Null，Boolean，Number，String）堆：引用数据类型（对象、数组、函数）两种类型的区别：存储位置不同//原始数据类型直接存储在栈(stack)中的简单数据段，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储；引用数据类型存储在堆(heap)中的对象,占据空间大、大小不固定,如果存储在栈中，将会影响程序运行的性能；引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。 JavaScript 如何实现继承？ 1234567891011121314151617(1)构造继承(2)原型继承(3)实例继承(4)拷贝继承//原型prototype机制或apply和call方法去实现较简单，建议使用构造函数与原型混合方式。function Parent() &#123; this.name = &apos;song&apos;;&#125;function Child() &#123; this.age = 28;&#125;Child.prototype = new Parent(); //通过原型,继承了Parent//var demo = new Child()l;alert(demo.age);alert(demo.name); //得到被继承的属性 JavaScript 有哪几种创建对象的方式？ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950javascript创建对象简单的说,无非就是使用内置对象或各种自定义对象，当然还可以用JSON；但写法有很多种，也能混合使用。//(1)对象字面量的方式person=&#123;firstname:&quot;Mark&quot;,lastname:&quot;Yun&quot;,age:25,eyecolor:&quot;black&quot;&#125;;(2)用function来模拟无参的构造函数function Person()&#123;&#125;var person = new Person(); //定义一个function，如果使用new&quot;实例化&quot;,该function可以看作是一个Classperson.name = &quot;Xiaosong&quot;;person.age = &quot;23&quot;;person.work = function() &#123; alert(&quot;Hello &quot; + person.name);&#125;person.work();(3)用function来模拟参构造函数来实现（用this关键字定义构造的上下文属性）function Person(name,age,hobby) &#123; this.name = name; //this作用域：当前对象 this.age = age; this.work = work; this.info = function() &#123; alert(&quot;我叫&quot; + this.name + &quot;，今年&quot; + this.age + &quot;岁，是个&quot; + this.work); &#125;&#125;var Xiaosong = new Person(&quot;WooKong&quot;,23,&quot;程序猿&quot;); //实例化、创建对象Xiaosong.info(); //调用info()方法(4)用工厂方式来创建（内置对象）var jsCreater = new Object();jsCreater.name = &quot;Brendan Eich&quot;; //JavaScript的发明者jsCreater.work = &quot;JavaScript&quot;;jsCreater.info = function() &#123; alert(&quot;我是&quot;+this.work+&quot;的发明者&quot;+this.name);&#125;jsCreater.info();(5)用原型方式来创建function Standard()&#123;&#125;Standard.prototype.name = &quot;ECMAScript&quot;;Standard.prototype.event = function() &#123; alert(this.name+&quot;是脚本语言标准规范&quot;);&#125;var jiaoben = new Standard();jiaoben.event();(6)用混合方式来创建function iPhone(name,event) &#123; this.name = name; this.event = event;&#125;iPhone.prototype.sell = function() &#123; alert(&quot;我是&quot;+this.name+&quot;，我是iPhone5s的&quot;+this.event+&quot;~ haha!&quot;);&#125;var SE = new iPhone(&quot;iPhone SE&quot;,&quot;官方翻新机&quot;);SE.sell(); eval 是做什么的？ 12它的功能是把对应的字符串解析成JS代码并运行；应该避免使用eval，因为不安全，非常耗性能（2次，一次解析成js语句，一次执行）。 什么是 document 对象？什么是 window 对象？ null 和 undefined 有何区别？ 123456789101112131415null 表示一个对象被定义了，值为“空值”；undefined 表示不存在这个值。//typeof undefined //&quot;undefined&quot; undefined :是一个表示&quot;无&quot;的原始值或者说表示&quot;缺少值&quot;，就是此处应该有一个值，但是还没有定义。当尝试读取时会返回 undefined； 例如变量被声明了，但没有赋值时，就等于undefined。//typeof null //&quot;object&quot; null : 是一个对象(空对象, 没有任何属性和方法)； 例如作为函数的参数，表示该函数的参数不是对象；//注意： 在验证null时，一定要使用 === ，因为 == 无法分别 null 和 undefined 能否写一个通用的事件侦听器函数？ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677//Event工具集，from:github.com/markyunmarkyun.Event = &#123; //页面加载完成后 readyEvent: function(fn) &#123; if (fn == null) &#123; fn = document; &#125; var oldonload = window.onload; if (typeof window.onload != &apos;function&apos;) &#123; window.onload = fn; &#125;else&#123; window.onload = function() &#123; oldonload(); fn(); &#125;; &#125; &#125;, //视能力分别使用 demo0 || demo1 || IE 方式来绑定事件 //参数：操作的元素，事件名称，事件处理程序 addEvent: function(element,type,handler) &#123; if (element.addEventListener) &#123; //事件类型、需要执行的函数、是否捕捉 element.addEventListener(type,handler,false); &#125;else if (element.attachEvent) &#123; element.attachEvent(&apos;on&apos; + type, function() &#123; handler.call(element); &#125;); &#125;else &#123; element[&apos;on&apos; + type] = handler; &#125; &#125;, //移除事件 removeEvent: function(element,type,handler) &#123; if (element.removeEventListener) &#123; element.removeEventListener(type,handler,false); &#125;else if (element.datachEvent) &#123; element.datachEvent(&apos;on&apos; + type,handler); &#125;else&#123; element[&apos;on&apos; + type] = null; &#125; &#125;, //阻止事件（主要是事件冒泡，因为IE不支持事件捕获） stopPropagation: function(ev) &#123; if (ev.stopPropagation) &#123; ev.stopPropagation(); &#125;else &#123; ev.cancelBubble = true; &#125; &#125;, //取消事件的默认行为 preventDefault: function(event) &#123; if (event.preventDefault) &#123; event.preventDefault(); &#125;else&#123; event.returnValue = false; &#125; &#125;, //获取事件目标 getTarget: function(event) &#123; return event.target || event.srcElemnt; &#125;, //获取event对象的引用，取到事件的所有信息，确保随时能使用event； getEvent: function(e) &#123; var ev = e || window.event; if (!ev) &#123; var c = this.getEvent.caller; while(c) &#123; ev = c.argument[0]; if (ev &amp;&amp; Event == ev.constructor) &#123; break; &#125; c = c.caller; &#125; &#125; retrun ev; &#125;&#125;; [“1”,”2”,”3”].map(parseInt) 的答案是多少？ 123[1,NaN,NaN]因为 parseInt 需要两个参数(val,radix)，其中 radix 表示解析时用的基数。map 传了3个(element,index,array)，对应的 radix 不合法导致解析失败。 事件是什么？IE与火狐的事件机制有何区别？如何阻止冒泡？ 123(1)我们在网页中的某个操作（有的操作对应多个事件）。例如：当我们点击一个按钮就会产生一个事件。是可以被 JavaScript 侦测到的行为。(2)事件处理机制：IE是事件冒泡、Firefox同时支持两种事件模型，也就是：捕获型事件和冒泡型事件；(3)ev.stopPropagation();（旧ie的方法 ev.cancelBubble = true;） 什么是闭包(closure)，为什么要用它？ 123456789101112131415161718192021闭包是指有权访问另一个函数作用域中变量的函数，创建闭包的最常见的方式就是在一个函数内创建另一个函数，通过另一个函数访问这个函数的局部变量，利用闭包可以突破作用链域，将函数内部的变量和方法传递到外部。//闭包特性：(1)函数内再嵌套函数(2)内部函数可以引用外层的参数和变量(3)参数和变量不会被垃圾回收机制回收//li节点的onclick事件都能正确的弹出当前被点击的li索引&lt;ul&gt; &lt;li&gt; index = 0 &lt;/li&gt; &lt;li&gt; index = 1 &lt;/li&gt; &lt;li&gt; index = 2 &lt;/li&gt; &lt;li&gt; index = 3 &lt;/li&gt;&lt;/ul&gt;&lt;script type=&quot;text/javascript&quot;&gt; var nodes = document.getElementsByTagName(&apos;li&apos;); for(i = 0;i&lt;nodes.length;i+=1) &#123; nodes[i].onclick = function() &#123; console.log(i+1); //不使用闭包的话，值每次都是4 &#125;(4); &#125;&lt;/script&gt; JavaScript 代码中的 “use strict”; 是什么意思？使用它的区别是什么？ 123456use strict是一种ECMAscript 5 添加的（严格）运行模式,这种模式使得 Javascript 在更严格的条件下运行,使JS编码更加规范化的模式,消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为。默认支持的糟糕特性都会被禁用，比如不能用with，也不能在意外的情况下给全局变量赋值;全局变量的显示声明,函数必须声明在顶层，不允许在非函数代码块内声明函数,arguments.callee也不允许使用；消除代码运行的一些不安全之处，保证代码运行的安全,限制函数中的arguments修改，严格模式下的eval函数的行为和非严格模式的也不相同;提高编译器效率，增加运行速度；为未来新版本的Javascript标准化做铺垫。 new 操作符具体干了什么呢？ 1234567(1)创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型。(2)属性和方法被加入到 this 引用的对象中。(3)新创建的对象由 this 所引用，并且最后隐式的返回 this 。//var obj = &#123;&#125;;obj.__proto__ = Base.prototype;Base.call(obj); 用原生的 JavaScript 实现过什么功能吗？ JavaScript 中，有一个函数，执行对象查找时，永远不会去查找原型，这个函数是哪个？ 12345678910hasOwnProperty//JavaScript 中 hasOwnProperty 函数方法是返回一个布尔值，指出一个对象是否具有指定名称的属性。此方法无法检查该对象的原型链中是否具有该属性；该属性必须是对象本身的一个成员。//使用方法：object.hasOwnProperty(proName)其中参数object是必选项，一个对象的实例。proName是必选项，一个属性名称的字符串值。//如果 object 具有指定名称的属性，那么JavaScript中hasOwnProperty函数方法返回 true，反之则返回 false。 你对 JSON 了解吗？ 1234JSON(JavaScript Object Notation)是一种轻量级的数据交换格式。它是基于JavaScript的一个子集。数据格式简单，易于读写，占用带宽小。如：&#123;&quot;age&quot;:&quot;12&quot;, &quot;name&quot;:&quot;back&quot;&#125; js延迟加载的方式有哪些？ 1defer和async、动态创建DOM方式（用得最多）、按需异步载入js Ajax 是什么？如何创建一个 Ajax ？ 12345678910ajax的全称：Asynchronous Javascript And XML。异步传输+js+xml。所谓异步，在这里简单地解释就是：向服务器发送请求的时候，我们不必等待结果，而是可以同时做其他的事情，等到有了结果它自己会根据设定进行后续操作，与此同时，页面是不会发生整页刷新的，提高了用户体验。//(1)创建XMLHttpRequest对象,也就是创建一个异步调用对象(2)创建一个新的HTTP请求,并指定该HTTP请求的方法、URL及验证信息(3)设置响应HTTP请求状态变化的函数(4)发送HTTP请求(5)获取异步调用返回的数据(6)使用JavaScript和DOM实现局部刷新 同步和异步的区别？ 123456同步的概念应该是来自于操作系统中关于同步的概念:不同进程为协同完成某项工作而在先后次序上调整(通过阻塞,唤醒等方式)。同步强调的是顺序性，谁先谁后；异步则不存在这种顺序性。//同步：浏览器访问服务器请求，用户看得到页面刷新，重新发请求,等请求完，页面刷新，新内容出现，用户看到新内容,进行下一步操作。//异步：浏览器访问服务器请求，用户正常操作，浏览器后端进行请求。等请求完，页面不刷新，新内容也会出现，用户看到新内容。 如何解决跨域问题？ 1jsonp、iframe、window.name、window.postMessage、服务器上设置代理页面 页面编码和被请求的资源编码如果不一致如何处理？ 谈一谈你对 ECMAScript6 的了解？ 12ECMAScript 6 是JavaScript语言的下一代标准，已经在2015年6月正式发布了。它的目标，是使得JavaScript语言可以用来编写复杂的大型应用程序，成为企业级开发语言。标准的制定者有计划，以后每年发布一次标准，使用年份作为标准的版本。因为当前版本的ES6是在2015年发布的，所以又称ECMAScript 2015。也就是说，ES6就是ES2015 ECMAScript 6 怎么写 class ，为何会出现 class？ 1234567891011ES6的class可以看作只是一个语法糖，它的绝大部分功能，ES5都可以做到，新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。//定义类class Point &#123; constructor(x,y) &#123; //构造方法 this.x = x; //this关键字代表实例对象 this.y = y; &#125; toString() &#123; return &apos;(&apos; + this.x + &apos;,&apos; + this.y + &apos;)&apos;; &#125;&#125; 异步加载 JS 的方式有哪些？ 123(1)defer，只支持 IE(2)async:(3)创建 script，插入到 DOM 中，加载完毕后 callBack document.write 和 innerHTML 有何区别？ 12document.write 只能重绘整个页面innerHTML 可以重绘页面的一部分 DOM 操作——怎样添加、移除、移动、复制、创建和查找节点？ 12345678910111213(1)创建新节点 createDocumentFragment() //创建一个DOM片段 createElement() //创建一个具体的元素 createTextNode() //创建一个文本节点(2)添加、移除、替换、插入 appendChild() removeChild() replaceChild() insertBefore() //在已有的子节点前插入一个新的子节点(3)查找 getElementsByTagName() //通过标签名称 getElementsByName() //通过元素的Name属性的值(IE容错能力较强，会得到一个数组，其中包括id等于name值的) getElementById() //通过元素Id，唯一性 数组和对象有哪些原生方法？能否列举一下？ 如何编写高性能 JavaScript ？详细文章：浅谈编写高性能的Javascript代码 哪些操作会造成内存泄漏？ 12345内存泄漏是指任何对象在您不再拥有或需要它之后任然存在。垃圾回收器定期扫描对象，并计算引用了每个对象的其他对象的数量，如果一个对象的引用数量为0（没有其他对象引用过该对象），或对该对象的惟一引用是循环的，那么该对象的内存即可回收。//setTimeout 的第一个参数使用字符串而非函数的话，会引发内存泄漏。闭包、控制台日志、循环（在两个对象彼此引用且彼此保留时，就会产生一个循环） 是否看过 jQuery 的源码？能否简单概括一下它的实现原理？ jQuery.fn 的 init 方法返回的 this 指的是什么对象？为什么要返回 this ？ jQuery 中如何将数组转化为 json 字符串，然后再转化回来？ 12345678910jQuery 中没有提供这个功能，所以需要先编写两个 jQuery 的扩展：$.fn.stringifyArray = function(array) &#123; return JSON.stringify(array)&#125;$.fn.parseArray = function(array) &#123; return JSON.parse(array)&#125;//然后调用:$(&quot;&quot;).stringifyArray(array) jQuery 的属性拷贝（extend）的实现原理是什么？如何实现深拷贝？ jQuery.extend 与 jQuery.fn.extend 有何区别？ jQuery 的队列是如何实现的？队列可以用在哪些地方？ jQuery 中一个对象可以同时绑定多个事件，这是如何实现的？ 是否了解针对 jQuery 性能的优化方法？ 12345678基于Class的选择性的性能相对于Id选择器开销很大，因为需遍历所有DOM元素。//频繁操作的DOM，先缓存起来再操作。用Jquery的链式调用更好。 比如：var str=$(&quot;a&quot;).attr(&quot;href&quot;); //for (var i = size; i &lt; arr.length; i++) &#123;&#125;for 循环每一次循环都查找了数组 (arr) 的.length 属性，在开始循环的时候设置一个变量来存储这个数字，可以让循环跑得更快：for (var i = size, length = arr.length; i &lt; length; i++) &#123;&#125; jQuery 与 jQuery UI 有何区别？ 12`jQuery`是一个js库，主要提供的功能是选择器，属性修改和事件绑定等等。`jQuery UI`则是在jQuery的基础上，利用jQuery的扩展性，设计的插件。提供了一些常用的界面元素，诸如对话框、拖动行为、改变大小行为等等 jQuery UI 如何自定义组件？ 如何判断当前脚本运行在浏览器还是 node 环境中？（阿里） 1通过判断 Global 对象是否为 window ，如果不为 window ，当前脚本没有运行在浏览器中 什么是“前端路由”？什么时候适合使用“前端路由”？“前端路由”有哪些优点和缺点？ 怎样用js实现千位分隔符？ 123456789正则 + replacefunction commafy(num) &#123; num = num + &apos;&apos;; var reg = /(-?d+)(d&#123;3&#125;)/; if (reg.test(num)) &#123; num = num.replace(reg, &apos;$1,$2&apos;); &#125; return num;&#125; 检测浏览器版本有哪些方式？ 123功能检测、userAgent 特征检测比如：navigator.userAgent//&quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/41.0.2272.101 Safari/537.36&quot; 谈谈你对 JavaScript 中的模块规范 CommonJS、AMD、CMD 的了解？ 1234//个人拙见| CommonJS | AMD | CMD ||--------------|---------|---------|| Node.js |RequireJS| SeaJS | 详细文章：浅析JS中的模块规范（CommonJS，AMD，CMD）、关于 CommonJS AMD CMD UMD 前端 MVC、MVVM1、MVC1234567模型（Model）：数据保存视图（View）：用户界面控制器（Controller）：业务逻辑(1)View 传送指令到 Controller(2)Controller 完成业务逻辑后，要求 Model 改变状态(3)Model 将新的数据发送到 View ，用户得到反馈所有通信都是单向的。 2、MVVM1234567模型（Model）视图（View）视图模型（ViewModel）(1)各部分间都是双向通信(2)View 与 Model 不发生联系，都通过 ViewModel 传递(3)View 非常薄，不部署任何业务逻辑，称为“被动视图”（Passive View），即没有任何主动性；而 ViewModel 非常厚，所有逻辑都部署在那里采用双向绑定（data-binding）：View 的变动，自动反映在 ViewModel ，反之亦然。","categories":[],"tags":[{"name":"知识点","slug":"知识点","permalink":"https://leehave.github.io/tags/知识点/"},{"name":"面试技巧","slug":"面试技巧","permalink":"https://leehave.github.io/tags/面试技巧/"}]},{"title":"es6中文手册","slug":"es6手册","date":"2016-08-02T09:24:17.000Z","updated":"2016-08-02T09:24:17.000Z","comments":true,"path":"2016/08/02/es6手册/","link":"","permalink":"https://leehave.github.io/2016/08/02/es6手册/","excerpt":"这是一个 ES2015(ES6) 的Cheatsheet，其中包括提示、小技巧、最佳实践和一些代码片段，帮助你完成日复一日的开发工作。 Table of Contents var 与 let / const 声明 代码执行块替换立即执行函数 箭头函数 字符串 解构 模块 参数 类 Symbols Maps WeakMaps Promises Generators Async Await","text":"这是一个 ES2015(ES6) 的Cheatsheet，其中包括提示、小技巧、最佳实践和一些代码片段，帮助你完成日复一日的开发工作。 Table of Contents var 与 let / const 声明 代码执行块替换立即执行函数 箭头函数 字符串 解构 模块 参数 类 Symbols Maps WeakMaps Promises Generators Async Await var versus let / const 除了 var 以外，我们现在多了两个新的标识符来声明变量的存储，它们就是 let 和 const。不同于 var ，let 和 const 语句不会造成声明提升。 一个 var 的例子: 1234567891011var snack = 'Meow Mix';function getFood(food) &#123; if (food) &#123; var snack = 'Friskies'; return snack; &#125; return snack;&#125;getFood(false); // undefined 让我们再观察下面语句中，使用 let 替换了 var 后的表现： 1234567891011let snack = 'Meow Mix';function getFood(food) &#123; if (food) &#123; let snack = 'Friskies'; return snack; &#125; return snack;&#125;getFood(false); // 'Meow Mix' 当我们重构使用 var 的老代码时，一定要注意这种变化。盲目使用 let 替换 var 后可能会导致预期意外的结果。 注意：let 和 const 是块级作用域语句。所以在语句块以外引用这些变量时，会造成引用错误 ReferenceError。 123console.log(x);let x = 'hi'; // ReferenceError: x is not defined 最佳实践: 在重构老代码时，var 声明需要格外的注意。在创建一个新项目时，使用 let 声明一个变量，使用 const 来声明一个不可改变的常量。 (回到目录) Replacing IIFEs with Blocks我们以往创建一个 立即执行函数 时，一般是在函数最外层包裹一层括号。ES6支持块级作用域（更贴近其他语言），我们现在可以通过创建一个代码块（Block）来实现，不必通过创建一个函数来实现， 12345(function () &#123; var food = 'Meow Mix';&#125;());console.log(food); // Reference Error 使用支持块级作用域的ES6的版本： 12345&#123; let food = 'Meow Mix';&#125;console.log(food); // Reference Error (回到目录) Arrow Functions一些时候，我们在函数嵌套中需要访问上下文中的 this。比如下面的例子： 123456789function Person(name) &#123; this.name = name;&#125;Person.prototype.prefixName = function (arr) &#123; return arr.map(function (character) &#123; return this.name + character; // Cannot read property 'name' of undefined &#125;);&#125;; 一种通用的方式是把上下文中的 this 保存在一个变量里： 12345678910function Person(name) &#123; this.name = name;&#125;Person.prototype.prefixName = function (arr) &#123; var that = this; // Store the context of this return arr.map(function (character) &#123; return that.name + character; &#125;);&#125;; 我们也可以把 this 通过属性传进去： 123456789function Person(name) &#123; this.name = name;&#125;Person.prototype.prefixName = function (arr) &#123; return arr.map(function (character) &#123; return this.name + character; &#125;, this);&#125;; 还可以直接使用 bind： 123456789function Person(name) &#123; this.name = name;&#125;Person.prototype.prefixName = function (arr) &#123; return arr.map(function (character) &#123; return this.name + character; &#125;.bind(this));&#125;; 使用 箭头函数，this 的值不用我们再做如上几段代码的特殊处理，直接使用即可。上面的代码可以重写为下面这样： 1234567function Person(name) &#123; this.name = name;&#125;Person.prototype.prefixName = function (arr) &#123; return arr.map(character =&gt; this.name + character);&#125;; 最佳实践：使用箭头函数，再也不用考虑 this 的问题了。 当我们编写只返回一个表达式值的简单函数时，也可以使用箭头函数，如下： 1var squares = arr.map(function (x) &#123; return x * x &#125;); // Function Expression 12const arr = [1, 2, 3, 4, 5];const squares = arr.map(x =&gt; x * x); // Arrow Function for terser implementation 最佳实践：尽可能地多使用 箭头函数。 (回到目录) Strings在ES6中，标准库也被同样增强了，像字符串对象就新增了 .includes() 和 .repeat() 方法。 .includes( )1234var string = 'food';var substring = 'foo';console.log(string.indexOf(substring) &gt; -1); 现在，我们可以使用 .inclues() 方法，替代以往判断内容 &gt; -1 的方式。.includes() 方法会极简地返回一个布尔值结果。 1234const string = 'food';const substring = 'foo';console.log(string.includes(substring)); // true .repeat( )1234567function repeat(string, count) &#123; var strings = []; while(strings.length &lt; count) &#123; strings.push(string); &#125; return strings.join('');&#125; 在ES6中，我们可以使用一个极简的方法来实现重复字符： 12// String.repeat(numberOfRepetitions)'meow'.repeat(3); // 'meowmeowmeow' Template Literals使用 字符串模板字面量，我可以在字符串中直接使用特殊字符，而不用转义。 1var text = \"This string contains \\\"double quotes\\\" which are escaped.\"; 1let text = `This string contains \"double quotes\" which don't need to be escaped anymore.`; 字符串模板字面量 还支持直接插入变量，可以实现字符串与变量的直接连接输出。 1234var name = 'Tiger';var age = 13;console.log('My cat is named ' + name + ' and is ' + age + ' years old.'); 更简单的版本： 1234const name = 'Tiger';const age = 13;console.log(`My cat is named $&#123;name&#125; and is $&#123;age&#125; years old.`); ES5中，我们要这样生成多行文本： 12345var text = ( 'cat\\n' + 'dog\\n' + 'nickelodeon'); 或者： 12345var text = [ 'cat', 'dog', 'nickelodeon'].join('\\n'); 字符串模板字面量 让我们不必特别关注多行字符串中的换行转义符号，直接换行即可： 1234let text = ( `catdognickelodeon`); 字符串模板字面量 内部可以使用表达式，像这样： 12let today = new Date();let text = `The time and date is $&#123;today.toLocaleString()&#125;`; (回到目录) Destructuring解构让我们可以使用非常便捷的语法，直接将数组或者对象中的值直接分别导出到多个变量中， Destructuring Arrays解构数组 12345var arr = [1, 2, 3, 4];var a = arr[0];var b = arr[1];var c = arr[2];var d = arr[3]; 1234let [a, b, c, d] = [1, 2, 3, 4];console.log(a); // 1console.log(b); // 2 Destructuring Objects解构对象 123var luke = &#123; occupation: 'jedi', father: 'anakin' &#125;;var occupation = luke.occupation; // 'jedi'var father = luke.father; // 'anakin' 12345let luke = &#123; occupation: 'jedi', father: 'anakin' &#125;;let &#123;occupation, father&#125; = luke;console.log(occupation); // 'jedi'console.log(father); // 'anakin' (回到目录) ModulesES6之前，浏览器端的模块化代码，我们使用像Browserify这样的库，在 Node.js 中，我们则使用 require。在ES6中，我们现在可以直接使用AMD 和 CommonJS这些模块了。 Exporting in CommonJS1234module.exports = 1;module.exports = &#123; foo: 'bar' &#125;;module.exports = ['foo', 'bar'];module.exports = function bar () &#123;&#125;; Exporting in ES6在ES6中，提供了多种设置模块出口的方式，比如我们要导出一个变量，那么使用 变量名 ： 12export let name = 'David';export let age = 25;​​ 还可以为对象 导出一个列表： 123456789function sumTwo(a, b) &#123; return a + b;&#125;function sumThree(a, b, c) &#123; return a + b + c;&#125;export &#123; sumTwo, sumThree &#125;; 我们也可以使用简单的一个 export 关键字来导出一个结果值： 1234567export function sumTwo(a, b) &#123; return a + b;&#125;export function sumThree(a, b, c) &#123; return a + b + c;&#125; 最后，我们可以 导出一个默认出口： 1234567891011121314function sumTwo(a, b) &#123; return a + b;&#125;function sumThree(a, b, c) &#123; return a + b + c;&#125;let api = &#123; sumTwo, sumThree&#125;;export default api; 最佳实践：总是在模块的 最后 使用 export default 方法。它让模块的出口更清晰明了，节省了阅读整个模块来寻找出口的时间。更多的是，在大量CommonJS模块中，通用的习惯是设置一个出口值或者出口对象。最受这个规则，可以让我们的代码更易读，且更方便的联合使用CommonJS和ES6模块。 Importing in ES6ES6提供了好几种模块的导入方式。我们可以单独引入一个文件： 1import 'underscore'; 这里需要注意的是， 整个文件的引入方式会执行该文件内的最上层代码。 就像Python一样，我们还可以命名引用： 1import &#123; sumTwo, sumThree &#125; from 'math/addition'; 我们甚至可以使用 as 给这些模块重命名： 1234import &#123; sumTwo as addTwoNumbers, sumThree as sumThreeNumbers&#125; from 'math/addition'; 另外，我们能 引入所有的东西（原文：import all the things） （也称为命名空间引入） 1import * as util from 'math/addition'; 最后，我们能可以从一个模块的众多值中引入一个列表： 12import * as additionUtil from 'math/addtion';const &#123; sumTwo, sumThree &#125; = additionUtil; 像这样引用默认对象： 12import api from 'math/addition';// Same as: import &#123; default as api &#125; from 'math/addition'; 我们建议一个模块导出的值应该越简洁越好，不过有时候有必要的话命名引用和默认引用可以混着用。如果一个模块是这样导出的： 12// foos.jsexport &#123; foo as default, foo1, foo2 &#125;; 那我们可以如此导入这个模块的值： 1import foo, &#123; foo1, foo2 &#125; from &apos;foos&apos;; 我们还可以导入commonjs模块，例如React： 12import React from 'react';const &#123; Component, PropTypes &#125; = React; 更简化版本： 1import React, &#123; Component, PropTypes &#125; from 'react'; 注意：被导出的值是被 绑定的（原文：bingdings），而不是引用。所以，改变一个模块中的值的话，会影响其他引用本模块的代码，一定要避免此种改动发生。 (回到目录) Parameters在ES5中，许多种方法来处理函数的 参数默认值（default values），参数数量（indefinite arguments），参数命名（named parameters）。ES6中，我们可以使用非常简洁的语法来处理上面提到的集中情况。 Default Parameters12345function addTwoNumbers(x, y) &#123; x = x || 0; y = y || 0; return x + y;&#125; ES6中，我们可以简单为函数参数启用默认值： 123function addTwoNumbers(x=0, y=0) &#123; return x + y;&#125; 123addTwoNumbers(2, 4); // 6addTwoNumbers(2); // 2addTwoNumbers(); // 0 Rest ParametersES5中，遇到参数数量不确定时，我们只能如此处理： 12345function logArguments() &#123; for (var i=0; i &lt; arguments.length; i++) &#123; console.log(arguments[i]); &#125;&#125; 使用 rest 操作符，我们可以给函数传入一个不确定数量的参数列表： 12345function logArguments(...args) &#123; for (let arg of args) &#123; console.log(arg); &#125;&#125; Named Parameters命名函数ES5中，当我们要处理多个 命名参数 时，通常会传入一个 选项对象 的方式，这种方式被jQuery采用。 12345function initializeCanvas(options) &#123; var height = options.height || 600; var width = options.width || 400; var lineStroke = options.lineStroke || 'black';&#125; 我们可以利用上面提到的新特性 解构 ，来完成与上面同样功能的函数：We can achieve the same functionality using destructuring as a formal parameterto a function: 12345function initializeCanvas( &#123; height=600, width=400, lineStroke='black'&#125;) &#123; // ... &#125; // Use variables height, width, lineStroke here 如果我们需要把这个参数变为可选的，那么只要把该参数解构为一个空对象就好了： 1234function initializeCanvas( &#123; height=600, width=400, lineStroke='black'&#125; = &#123;&#125;) &#123; // ... &#125; Spread Operator我们可以利用展开操作符（Spread Operator）来把一组数组的值，当作参数传入： 1Math.max(...[-1, 100, 9001, -32]); // 9001 (回到目录) Classes在ES6以前，我们实现一个类的功能的话，需要首先创建一个构造函数，然后扩展这个函数的原型方法，就像这样： 123456789function Person(name, age, gender) &#123; this.name = name; this.age = age; this.gender = gender;&#125;Person.prototype.incrementAge = function () &#123; return this.age += 1;&#125;; 继承父类的子类需要这样： 1234567891011function Personal(name, age, gender, occupation, hobby) &#123; Person.call(this, name, age, gender); this.occupation = occupation; this.hobby = hobby;&#125;Personal.prototype = Object.create(Person.prototype);Personal.prototype.constructor = Personal;Personal.prototype.incrementAge = function () &#123; return Person.prototype.incrementAge.call(this) += 20;&#125;; ES6提供了一些语法糖来实现上面的功能，我们可以直接创建一个类： 1234567891011class Person &#123; constructor(name, age, gender) &#123; this.name = name; this.age = age; this.gender = gender; &#125; incrementAge() &#123; this.age += 1; &#125;&#125; 继承父类的子类只要简单的使用 extends 关键字就可以了： 12345678910111213class Personal extends Person &#123; constructor(name, age, gender, occupation, hobby) &#123; super(name, age, gender); this.occupation = occupation; this.hobby = hobby; &#125; incrementAge() &#123; super.incrementAge(); this.age += 20; console.log(this.age); &#125;&#125; 最佳实践：ES6新的类语法把我们从晦涩难懂的实现和原型操作中解救出来，这是个非常适合初学者的功能，而且能让我们写出更干净整洁的代码。 (回到目录) Symbols符号（Symbols）在ES6版本之前就已经存在了，但现在我们拥有一个公共的接口来直接使用它们。Symbols对象是一旦创建就不可以被更改的（immutable）而且能被用做hash数据类型中的键。 Symbol( )调用 Symbol() 或者 Symbol(描述文本) 会创建一个唯一的、在全局中不可以访问的符号对象。一个 Symbol() 的应用场景是：在自己的项目中使用第三方代码库，且你需要给他们的对象或者命名空间打补丁代码，又不想改动或升级第三方原有代码的时候。举个例子，如果你想给 React.Component 这个类添加一个 refreshComponent 方法，但又确定不了这个方法会不会在下个版本中加入，你可以这么做： 12345const refreshComponent = Symbol();React.Component.prototype[refreshComponent] = () =&gt; &#123; // do something&#125; Symbol.for(key)使用 Symbol.for(key) 也是会创建一个不可改变的Symbol对象，但区别于上面的创建方法，这个对象是在全局中可以被访问到的。调用两次 Symbol.for(key) 会返回相同的Symbol实例。 提示：这并不同于 Symbol(description)。 123Symbol('foo') === Symbol('foo') // falseSymbol.for('foo') === Symbol('foo') // falseSymbol.for('foo') === Symbol.for('foo') // true 一个Symbols常用的使用场景，是需要使用特别 Symbol.for(key) 方法来实现代码间的协作。这能让你在你的代码中，查找包含已知的接口的第三方代码中Symbol成员。（译者：这句话好难翻。。。原文：This can beachieved by having your code look for a Symbol member on object arguments from third parties that contain some known interface. ）举个例子： 123456789function reader(obj) &#123; const specialRead = Symbol.for('specialRead'); if (obj[specialRead]) &#123; const reader = obj[specialRead](); // do something with reader &#125; else &#123; throw new TypeError('object cannot be read'); &#125;&#125; 之后在另一个库中： 12345678const specialRead = Symbol.for('specialRead');class SomeReadableType &#123; [specialRead]() &#123; const reader = createSomeReaderFrom(this); return reader; &#125;&#125; 注意：Symbol.iterable 在ES6中像其他可枚举的对象，如数组，字符串，generators一样，当这个方法被调用时会激活一个枚举器并返回一个对象。 (回到目录) MapsMaps 是一个Javascript中很重要（迫切需要）的数据结构。在ES6之前，我们创建一个 hash 通常是使用一个对象： 123var map = new Object();map[key1] = 'value1';map[key2] = 'value2'; 但是，这样的代码无法避免函数被特别的属性名覆盖的意外情况： 12&gt; getOwnProperty(&#123; hasOwnProperty: 'Hah, overwritten'&#125;, 'Pwned');&gt; TypeError: Property 'hasOwnProperty' is not a function Maps 让我们使用 set，get 和 search 操作数据。 1234let map = new Map();&gt; map.set('name', 'david');&gt; map.get('name'); // david&gt; map.has('name'); // true Maps最强大的地方在于我们不必只能使用字符串来做key了，现在可以使用任何类型来当作key，而且key不会被强制类型转换为字符串。 123456789101112let map = new Map([ ['name', 'david'], [true, 'false'], [1, 'one'], [&#123;&#125;, 'object'], [function () &#123;&#125;, 'function']]);for (let key of map.keys()) &#123; console.log(typeof key); // &gt; string, boolean, number, object, function&#125; 提示：当使用 map.get() 判断值是否相等时，非基础类型比如一个函数或者对象，将不会正常工作。有鉴于此，还是建议使用字符串，布尔和数字类型的数据类型。 我们还可以使用 .entries() 方法来遍历整个map对象： 123for (let [key, value] of map.entries()) &#123; console.log(key, value);&#125; (回到目录) WeakMaps在ES5之前的版本，我们为了存储私有数据，有好几种方法。像使用这种下划线命名约定： 123456789class Person &#123; constructor(age) &#123; this._age = age; &#125; _incrementAge() &#123; this._age += 1; &#125;&#125; 在一个开源项目中，命名规则很难维持得一直很好，这样经常会造成一些困扰。此时，我们可以选择使用WeakMaps来替代Maps来存储我们的数据： 1234567891011121314let _age = new WeakMap();class Person &#123; constructor(age) &#123; _age.set(this, age); &#125; incrementAge() &#123; let age = _age.get(this) + 1; _age.set(this, age); if (age &gt; 50) &#123; console.log('Midlife crisis'); &#125; &#125;&#125; 使用WeakMaps来保存我们私有数据的理由之一是不会暴露出属性名，就像下面的例子中的 Reflect.ownKeys()： 123&gt; const person = new Person(50);&gt; person.incrementAge(); // 'Midlife crisis'&gt; Reflect.ownKeys(person); // [] 一个使用WeakMaps存储数据更实际的例子，就是有关于一个DOM元素和对该DOM元素（有污染）地操作： 1234567891011121314let map = new WeakMap();let el = document.getElementById('someElement');// Store a weak reference to the element with a keymap.set(el, 'reference');// Access the value of the elementlet value = map.get(el); // 'reference'// Remove the referenceel.parentNode.removeChild(el);el = null;value = map.get(el); // undefined 上面的例子中，一个对象被垃圾回收期给销毁了，WeakMaps会自动的把自己内部所对应的键值对数据同时销毁。 提示：结合这个例子，再考虑下jQuery是如何实现缓存带有引用的DOM元素这个功能的，使用了WeakMaps的话，当被缓存的DOM元素被移除的时，jQuery可以自动释放相应元素的内存。通常情况下，在涉及DOM元素存储和缓存的情况下，使用WeakMaps是非常适合的。 (回到目录) PromisesPromises让我们让我们多缩进难看的代码（回调地狱）： 1234567891011func1(function (value1) &#123; func2(value1, function (value2) &#123; func3(value2, function (value3) &#123; func4(value3, function (value4) &#123; func5(value4, function (value5) &#123; // Do something with value 5 &#125;); &#125;); &#125;); &#125;);&#125;); 写成这样： 1234567func1(value1) .then(func2) .then(func3) .then(func4) .then(func5, value5 =&gt; &#123; // Do something with value 5 &#125;); 在ES6之前，我们使用bluebird 或者Q。现在我们有了原生版本的 Promises： 123new Promise((resolve, reject) =&gt; reject(new Error('Failed to fulfill Promise'))) .catch(reason =&gt; console.log(reason)); 这里有两个处理函数，resolve（当Promise执行成功完毕时调用的回调函数） 和 reject （当Promise执行不接受时调用的回调函数） Promises的好处：大量嵌套错误回调函数会使代码变得难以阅读理解。使用了Promises，我们可以让我们代码变得更易读，组织起来更合理。此外，Promise处理后的值，无论是解决还是拒绝的结果值，都是不可改变的。 下面是一些使用Promises的实际例子： 1234567var fetchJSON = function(url) &#123; return new Promise((resolve, reject) =&gt; &#123; $.getJSON(url) .done((json) =&gt; resolve(json)) .fail((xhr, status, err) =&gt; reject(status + err.message)); &#125;);&#125;; 我们还可以使用 Promise.all() 来异步的 并行 处理一个数组的数据。 123456789101112131415var urls = [ 'http://www.api.com/items/1234', 'http://www.api.com/items/4567'];var urlPromises = urls.map(fetchJSON);Promise.all(urlPromises) .then(function (results) &#123; results.forEach(function (data) &#123; &#125;); &#125;) .catch(function (err) &#123; console.log('Failed: ', err); &#125;); (回到目录) Generators就像Promises如何让我们避免回调地狱一样，Generators也可以使我们的代码扁平化，同时给予我们开发者像开发同步代码一样的感觉来写异步代码。Generators本质上是一种支持的函数，随后返回表达式的值。Generators实际上是支持暂停运行，随后根据上一步的返回值再继续运行的一种函数。 下面代码是一个使用generators函数的简单例子： 123456789101112function* sillyGenerator() &#123; yield 1; yield 2; yield 3; yield 4;&#125;var generator = sillyGenerator();&gt; console.log(generator.next()); // &#123; value: 1, done: false &#125;&gt; console.log(generator.next()); // &#123; value: 2, done: false &#125;&gt; console.log(generator.next()); // &#123; value: 3, done: false &#125;&gt; console.log(generator.next()); // &#123; value: 4, done: false &#125; 就像上面的例子，当next运行时，它会把我们的generator向前“推动”，同时执行新的表达式。我们能利用Generators来像书写同步代码一样书写异步代码。 1234567// Hiding asynchronousity with Generatorsfunction request(url) &#123; getJSON(url, function(response) &#123; generator.next(response); &#125;);&#125; 这里我们写个generator函数将要返回我们的数据： 123456function* getData() &#123; var entry1 = yield request('http://some_api/item1'); var data1 = JSON.parse(entry1); var entry2 = yield request('http://some_api/item2'); var data2 = JSON.parse(entry2);&#125; 借助于 yield，我们可以保证 entry1 确实拿到数据并转换后再赋值给 data1。 当我们使用generators来像书写同步代码一样书写我们的异步代码逻辑时，没有一种清晰简单的方式来处理期间可能会产生的错误或者异常。在这种情况下，我们可以在我们的generator中引入Promises来处理，就像下面这样： 12345function request(url) &#123; return new Promise((resolve, reject) =&gt; &#123; getJSON(url, resolve); &#125;);&#125; 我们再写一个函数，其中使用 next 来步进我们的generator的同事，再利用我们上面的 request 方法来产生（yield）一个Promise。 12345678910function iterateGenerator(gen) &#123; var generator = gen(); var ret; (function iterate(val) &#123; ret = generator.next(); if(!ret.done) &#123; ret.value.then(iterate); &#125; &#125;)();&#125; 在Generator中引入了Promises后，我们就可以通过Promise的 .catch 和 reject 来捕捉和处理错误了。使用了我们新版的Generator后，新版的调用就像老版本一样简单可读（译者注：有微调）： 123456iterateGenerator(function* getData() &#123; var entry1 = yield request('http://some_api/item1'); var data1 = JSON.parse(entry1); var entry2 = yield request('http://some_api/item2'); var data2 = JSON.parse(entry2);&#125;); 在使用Generator后，我们可以重用我们的老版本代码实现，以此展示了Generator的力量。当使用Generators和Promises后，我们可以像书写同步代码一样书写异步代码的同时优雅地解决了错误处理问题。此后，我们实际上可以开始利用更简单的一种方式了，它就是async-await。 (回到目录) Async Awaitasync await 随着ES2016版本就要发布了，它给我们提供了一种更轻松的、更简单的可以替代的实现上面 Generators 配合 Promises 组合代码的一种编码方式，让我们来看看例子： 12345678910111213141516var request = require('request');function getJSON(url) &#123; return new Promise(function(resolve, reject) &#123; request(url, function(error, response, body) &#123; resolve(body); &#125;); &#125;);&#125;async function main() &#123; var data = await getJSON(); console.log(data); // NOT undefined!&#125;main(); 它们看上去和Generators很像。我（作者）强烈推荐使用 async await 来替代Generators + Promises的写法。这里是个很好的学习资源，让我们学习和使用这项ES7中的新功能。 (回到目录)","categories":[],"tags":[{"name":"ECMAscript","slug":"ECMAscript","permalink":"https://leehave.github.io/tags/ECMAscript/"}]},{"title":"导演很无语","slug":"something","date":"2016-07-31T16:03:29.000Z","updated":"2016-07-31T16:03:29.000Z","comments":true,"path":"2016/08/01/something/","link":"","permalink":"https://leehave.github.io/2016/08/01/something/","excerpt":"","text":"有点蛋疼的是,换了工作后,博客源文件忘了拷走,现在重新搭建了一遍,好在是用 ‘nodejs’ 强力驱动,hexo的博客驱动还是很给力的,我这种懒人,弄了个WordPress到现在还没设计好怎么搞好,最近发生了好多事,措手不及也是意料之中。————————————————————————分割线 最近在学各种js框架和夯实基础(走的时候茶杯水漏了把犀牛书弄湿了,心塞–),在这分享点资源awesome前端库(https://www.awesomes.cn/) 醉牛前端(http://f2er.club/) talkingcoder(http://www.talkingcoder.com/) React Native 构建 Facebook F8 2016 App / React Native 开发指南http://f8-app.liaohuqiu.net/ React-Native入门指南https://github.com/vczero/react-native-lesson 30天学习React Native教程https://github.com/fangwei716/30-days-of-react-native React-Native视频教程(部分免费)https://egghead.io/technologies/react Angularjs angular2https://angular.cn/ 使用typescript撰写的angularjs风格apphttps://github.com/NoctisHsu/91APP-TypeScript-Angularjs Vuejs 基于vue.js重写Cnodejs.org社区的webapphttps://github.com/shinygang/Vue-cnodejs **基于 Vue.js 的移动端组件库Mint Uihttp://mint-ui.github.io/#!/zh-cn 这个不得不说一个 国产的vuer们称作kpi项目的 阿里巴巴的weexhttp://alibaba.github.io/weex/doc/tutorial.html","categories":[],"tags":[]},{"title":"Webpack 中文指南","slug":"webpack","date":"2016-07-31T15:32:37.000Z","updated":"2016-07-31T15:32:37.000Z","comments":true,"path":"2016/07/31/webpack/","link":"","permalink":"https://leehave.github.io/2016/07/31/webpack/","excerpt":"Webpack 是当下最热门的前端资源模块化管理和打包工具。它可以将许多松散的模块按照依赖和规则打包成符合生产环境部署的前端资源。还可以将按需加载的模块进行代码分隔，等到实际需要的时候再异步加载。通过 loader 的转换，任何形式的资源都可以视作模块，比如 CommonJs 模块、 AMD 模块、 ES6 模块、CSS、图片、 JSON、Coffeescript、 LESS 等。 主站 · 下载电子版 · 国内镜像1（掘金）· 国内镜像2（极客学院）","text":"Webpack 是当下最热门的前端资源模块化管理和打包工具。它可以将许多松散的模块按照依赖和规则打包成符合生产环境部署的前端资源。还可以将按需加载的模块进行代码分隔，等到实际需要的时候再异步加载。通过 loader 的转换，任何形式的资源都可以视作模块，比如 CommonJs 模块、 AMD 模块、 ES6 模块、CSS、图片、 JSON、Coffeescript、 LESS 等。 主站 · 下载电子版 · 国内镜像1（掘金）· 国内镜像2（极客学院） 贡献内容如果你想参与这本书的共同创作，修改或添加内容，可以先 Fork 这本书的仓库，然后将修改的内容提交 Pull requests ；或者创建 Issues。 Fork 后的仓库如何同步本仓库？ 123456789101112// 添加 upstream 源，只需执行一次$ git remote add upstream git@github.com:zhaoda/webpack-handbook.git// 拉取远程代码$ git pull upstream master// 提交修改$ git add .$ git commit// 更新 fork 仓库$ git push origin master 更多参考： Syncing a fork 注意，本书内容在 /content 目录中， gh-pages 分支和 Wiki 版是通过脚本自动生成的。 生成电子书这本书使用 Gitbook 撰写并生成网站，请查看 package.json 中的 scripts 配置和 /scripts 目录中的脚本来了解这本书的构建和发布过程。 123456789101112131415161718192021222324// 初始化 nodejs 依赖$ npm install// 安装 gitbook 插件$ npm install gitbook-cli -g$ gitbook install ./content// 启动 gitbook 服务开始撰写工作$ npm run serve-gitbook// 生成 gitbook$ npm run generate-gitbook// 生成 wiki$ npm run generate-wiki// 发布到 gh-pages 分支$ npm run deploy-gitbook// 发布到 wiki$ npm run deploy-wiki// 生成并发布，是上面4条命令的快捷方式，通常编辑内容后只需要进行这个操作$ npm run generate-and-deploy 更新日志https://github.com/zhaoda/webpack-handbook/commits/master 版权许可 Webpack 中文指南 由 赵达 创作，采用 知识共享 署名-非商业性使用 4.0 国际 许可协议进行许可。","categories":[],"tags":[{"name":"webpack","slug":"webpack","permalink":"https://leehave.github.io/tags/webpack/"},{"name":"前端打包工具","slug":"前端打包工具","permalink":"https://leehave.github.io/tags/前端打包工具/"},{"name":"模块化","slug":"模块化","permalink":"https://leehave.github.io/tags/模块化/"}]}]}